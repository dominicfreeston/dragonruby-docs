<!DOCTYPE html><html><head><link rel="stylesheet" href="/css/preflight.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/nord.min.css" /><script src="/js/highlight.min.js"></script><script>hljs.highlightAll();</script></head><body><div id="section---runtime-"><h1 id="---runtime-"><code>Runtime</code></h1><p>
The <code>GTK::Runtime</code> class is the core of DragonRuby. It is globally accessible via <code>$gtk</code> or inside of the <code>tick</code> method through <code>args</code>.
</p><pre><code class="language-ruby">def tick args
  args.gtk # accessible like this
  $gtk # or like this
end
</code></pre><div><h2 id="----get_pixels-"><code>get_pixels</code></h2><p>
Given a <code>file_path</code> to a sprite, this function returns a one dimensional array of hexadecimal values representing the ARGB of each pixel in a sprite.
</p><p>
See the following sample app for a full demonstration of how to use this function: <code>./samples/07_advanced_rendering/06_pixel_arrays_from_file</code>
</p></div><div><h2 id="----dlopen-"><code>dlopen</code></h2><p>
Loads a precompiled C Extension into your game.
</p><p>
See the sample apps at <code>./samples/12_c_extensions</code> for detailed walkthroughs of creating C extensions.
</p></div><div><h2 id="----calcstringbox-"><code>calcstringbox</code></h2><p>
Returns the render width and render height as a tuple for a piece of text. The parameters this method takes are:
</p><ul>
<li><code>text</code>: the text you want to get the width and height of.</li>
<li><code>size_enum</code>: number representing the render size for the text. This
  parameter is optional and defaults to <code>0</code> which represents a   baseline font size in units specific to DragonRuby (a negative value   denotes a size smaller than what would be comfortable to read on a   handheld device postive values above <code>0</code> represent larger font sizes).</li>
<li><code>font</code>: path to a font file that the width and height will be based
  off of. This field is optional and defaults to the DragonRuby's   default font.</li>
</ul><pre><code class="language-ruby">def tick args
  text = "a piece of text"
  size_enum = 5 # "large font size"

  # path is relative to your game directory (eg mygame/fonts/courier-new.ttf)
  font = "fonts/courier-new.ttf"

  # get the render width and height
  string_w, string_h = args.gtk.calcstringbox text, size_enum, font

  # render the label
  args.outputs.labels &lt;&lt; {
    x: 100,
    y: 100,
    text: text,
    size_enum: size_enum,
    font: font
  }

  # render a border around the label based on the results from calcstringbox
  args.outputs.borders &lt;&lt; {
    x: 100,
    y: 100,
    w: string_w,
    h: string_h,
    r: 0,
    g: 0,
    b: 0
  }
end
</code></pre></div><div><h2 id="----request_quit-"><code>request_quit</code></h2><p>
Call this function to exit your game. You will be given one additional tick if you need to perform any housekeeping before that game closes.
</p><pre><code class="language-ruby">def tick args
  # exit the game after 600 frames (10 seconds)
  if args.state.tick_count == 600
    args.gtk.request_quit
  end
end
</code></pre></div><div><h2 id="----quit_requested--"><code>quit_requested?</code></h2><p>
This function will return <code>true</code> if the game is about to exit (either from the user closing the game or if <code>request_quit</code> was invoked).
</p></div><div><h2 id="----set_window_fullscreen-"><code>set_window_fullscreen</code></h2><p>
This function takes in a single boolean parameter. <code>true</code> to make the game fullscreen, <code>false</code> to return the game back to windowed mode.
</p><pre><code class="language-ruby">def tick args
  # make the game full screen after 600 frames (10 seconds)
  if args.state.tick_count == 600
    args.gtk.set_window_fullscreen true
  end

  # return the game to windowed mode after 20 seconds
  if args.state.tick_count == 1200
    args.gtk.set_window_fullscreen false
  end
end
</code></pre></div><div><h2 id="----window_fullscreen--"><code>window_fullscreen?</code></h2><p>
Returns true if the window is currently in fullscreen mode.
</p></div><div><h2 id="----platform--"><code>platform?</code></h2><p>
You can ask DragonRuby which platform your game is currently being run on. This can be useful if you want to perform different pieces of logic based on where the game is running.
</p><p>
The raw platform string value is available via <code>args.gtk.platform</code> which takes in a <code>symbol</code> representing the platform's categorization/mapping.
</p><p>
You can see all available platform categorizations via the <code>args.gtk.platform_mappings</code> function.
</p><p>
Here's an example of how to use <code>args.gtk.platform? category_symbol</code>:
</p><pre><code class="language-ruby">def tick args
  if    args.gtk.platform? :macos
    args.outputs.labels &lt;&lt; { x: 640, y: 360,
                             text: "I am running on MacOS.", alignment_enum: 1 }
  elsif args.gtk.platform? :win
    args.outputs.labels &lt;&lt; { x: 640, y: 360,
                             text: "I am running on Windows.", alignment_enum: 1 }
  elsif args.gtk.platform? :linux
    args.outputs.labels &lt;&lt; { x: 640, y: 360,
                             text: "I am running on Linux.", alignment_enum: 1 }
  elsif args.gtk.platform? :web
    args.outputs.labels &lt;&lt; { x: 640, y: 360,
                             text: "I am running on a web page.", alignment_enum: 1 }
  elsif args.gtk.platform? :android
    args.outputs.labels &lt;&lt; { x: 640, y: 360,
                             text: "I am running on Android.", alignment_enum: 1 }
  elsif args.gtk.platform? :ios
    args.outputs.labels &lt;&lt; { x: 640, y: 360,
                             text: "I am running on iOS.", alignment_enum: 1 }
  end
end
</code></pre></div><div><h2 id="----platform_mappings-"><code>platform_mappings</code></h2><p>
These are the current platform categorizations (<code>args.gtk.platform_mappings</code>):
</p><pre><code class="language-ruby">{
  "Mac OS X"   =&gt; [:desktop, :macos, :osx, :mac, :macosx],
  "Windows"    =&gt; [:desktop, :windows, :win],
  "Linux"      =&gt; [:desktop, :linux, :nix],
  "Emscripten" =&gt; [:web,     :wasm, :html, :emscripten],
  "iOS"        =&gt; [:mobile,  :ios, ],
  "Android"    =&gt; [:mobile,  :android],
}
</code></pre><p>
Given the mappings above, <code>args.gtk.platform? :desktop</code> would return <code>true</code> if the game is running on a player's computer irrespective of OS (MacOS, Linux, and Windows are all categorized as <code>:desktop</code> platforms).
</p></div><div><h2 id="----open_url-"><code>open_url</code></h2><p>
Given a uri represented as a string. This fuction will open the uri in the user's default browser.
</p><pre><code class="language-ruby">def tick args
  # open a url after 600 frames (10 seconds)
  if args.state.tick_count == 600
    args.gtk.open_url "http://dragonruby.org"
  end
end
</code></pre></div><div><h2 id="----system-"><code>system</code></h2><p>
Given an OS dependent cli command represented as a string, this function executes the command and <code>puts</code> the results to the DragonRuby Console (returns <code>nil</code>).
</p><pre><code class="language-ruby">def tick args
  # execute ls on the current directory in 10 seconds
  if args.state.tick_count == 600
    args.gtk.system "ls ."
  end
end
</code></pre></div><div><h2 id="----exec-"><code>exec</code></h2><p>
Given an OS dependent cli command represented as a string, this function executes the command and returns a <code>string</code> representing the results.
</p><pre><code class="language-ruby">def tick args
  # execute ls on the current directory in 10 seconds
  if args.state.tick_count == 600
    results = args.gtk.exec "ls ."
    puts "The results of the command are:"
    puts results
  end
end
</code></pre></div><div><h2 id="----show_cursor-"><code>show_cursor</code></h2><p>
Shows the mouse cursor.
</p></div><div><h2 id="----hide_cursor-"><code>hide_cursor</code></h2><p>
Hides the mouse cursor.
</p></div><div><h2 id="----cursor_shown--"><code>cursor_shown?</code></h2><p>
Returns <code>true</code> if the mouse cursor is visible.
</p></div><div><h2 id="----set_mouse_grab-"><code>set_mouse_grab</code></h2><p>
Takes in a numeric parameter representing the mouse grab mode.
</p><ul>
<li><code>0</code>: Ungrabs the mouse.</li>
<li><code>1</code>: Grabs the mouse.</li>
<li><code>2</code>: Hides the cursor, grabs the mouse and puts it in relative position mode accessible via <code>args.inputs.mouse.relative_(x|y)</code>.</li>
</ul></div><div><h2 id="----set_system_cursor-"><code>set_system_cursor</code></h2><p>
Takes in a string value of <code>"arrow"</code>, <code>"ibeam"</code>, <code>"wait"</code>, or <code>"hand"</code> and sets the mouse curosor to the corresponding system cursor (if available on the OS).
</p></div><div><h2 id="----set_cursor-"><code>set_cursor</code></h2><p>
Replaces the mouse cursor with a sprite. Takes in a <code>path</code> to the sprite, and optionally an <code>x</code> and <code>y</code> value representing the realtive positioning the sprite will have to the mouse cursor.
</p><pre><code class="language-ruby">def tick args
  if args.state.tick_count == 0
    # assumes a sprite of size 80x80 and centers the sprite
    # relative to the cursor position.
    args.gtk.set_cursor "sprites/square/blue.png", 40, 40
  end
end
</code></pre></div><div><h2 id="----list_files-"><code>list_files</code></h2><p>
This function takes in one parameter. The parameter is the directory path and assumes the the game directory is the root. The method returns an <code>Array</code> of <code>String</code> representing all files within the directory. Use <code>stat_file</code> to determine whether a specific path is a file or a directory.
</p></div><div><h2 id="----stat_file-"><code>stat_file</code></h2><p>
This function takes in one parameter. The parameter is the file path and assumes the the game directory is the root. The method returns <code>nil</code> if the file doesn't exist otherwise it returns a <code>Hash</code> with the following information:
</p><pre><code class="language-ruby"># {
#   path: String,
#   file_size: Int,
#   mod_time: Int,
#   create_time: Int,
#   access_time: Int,
#   readonly: Boolean,
#   file_type: Symbol (:regular, :directory, :symlink, :other),
# }

def tick args
  if args.inputs.mouse.click
    args.gtk.write_file "last-mouse-click.txt", "Mouse was clicked at #{args.state.tick_count}."
  end

  file_info = args.gtk.stat_file "last-mouse-click.txt"

  if file_info
    args.outputs.labels &lt;&lt; {
      x: 30,
      y: 30.from_top,
      text: file_info.to_s,
      size_enum: -3
    }
  else
    args.outputs.labels &lt;&lt; {
      x: 30,
      y: 30.from_top,
      text: "file does not exist, click to create file",
      size_enum: -3
    }
  end
end
</code></pre></div><div><h2 id="----read_file-"><code>read_file</code></h2><p>
Given a file path, a string will be returned representing the contents of the file. <code>nil</code> will be returned if the file does not exist. You can use <code>stat_file</code> to get additional information of a file.
</p></div><div><h2 id="----write_file-"><code>write_file</code></h2><p>
This function takes in two parameters. The first parameter is the file path and assumes the the game directory is the root. The second parameter is the string that will be written. The method **overwrites** whatever is currently in the file. Use <code>append_file</code> to append to the file as opposed to overwriting.
</p><pre><code class="language-ruby">def tick args
  if args.inputs.mouse.click
    args.gtk.write_file "last-mouse-click.txt", "Mouse was clicked at #{args.state.tick_count}."
  end
end
</code></pre></div><div><h2 id="----append_file-"><code>append_file</code></h2><p>
This function takes in two parameters. The first parameter is the file path and assumes the the game directory is the root. The second parameter is the string that will be written. The method appends to whatever is currently in the file (a new file is created if one does not alread exist). Use <code>write_file</code> to overwrite the file's contents as opposed to appending.
</p><pre><code class="language-ruby">def tick args
  if args.inputs.mouse.click
    args.gtk.write_file "last-mouse-click.txt", "Mouse was clicked at #{args.state.tick_count}."
  end
end
</code></pre></div><div><h2 id="----delete_file-"><code>delete_file</code></h2><p>
This function takes in a single parameters. The parameter is the file path that should be deleted. This function will raise an exception if the path requesting to be deleted does not exist.
</p><p>
Notes:
</p><ul>
<li>Use <code>delete_if_exist</code> to only delete the file if it exists.</li>
<li>Use <code>stat_file</code> to determine if a path exists.</li>
<li>Use <code>list_files</code> to determine if a directory is empty.</li>
<li>You cannot delete files outside of your sandboxed game environment.</li>
</ul><p>
Here is a list of reasons an exception could be raised:
</p><p>
  - If the path is not found.   - If the path is still open (for reading or writing).   - If the path is not a file or directory.   - If the path is a circular symlink.   - If you do not have permissions to delete the path.   - If the directory attempting to be deleted is not empty.
</p><pre><code class="language-ruby">def tick args
  if args.inputs.mouse.click
    args.gtk.write_file "last-mouse-click.txt", "Mouse was clicked at #{args.state.tick_count}."
  end
end
</code></pre></div><div><h2 id="----delete_file_if_exist-"><code>delete_file_if_exist</code></h2><p>
Has the same behavior as <code>delete_file</code> except this function does not throw an exception.
</p></div><div><h2 id="----parse_json-"><code>parse_json</code></h2><p>
Given a json string, this function returns a hash representing the json data.
</p><pre><code class="language-ruby">sh = args.gtk.parse_json '{ "name": "John Doe", "aliases": ["JD"] }'
structure of hash: { "name"=&gt;"John Doe", "aliases"=&gt;["JD"] }
</code></pre></div><div><h2 id="----parse_json_file-"><code>parse_json_file</code></h2><p>
Same behavior as <code>parse_json_file</code> except a file path is read for the json string.
</p></div><div><h2 id="----parse_xml-"><code>parse_xml</code></h2><p>
Given xml data as a string, this function will return a hash that represents the xml data in the following recursive structure:
</p><pre><code class="language-ruby">
type: :element,
name: "Person",
children: [...]

</code></pre></div><div><h2 id="----parse_xml_file-"><code>parse_xml_file</code></h2><p>
Function has the same behavior as <code>parse_xml</code> except that the parameter must be a file path that contains xml contents.
</p></div><div><h2 id="----http_get-"><code>http_get</code></h2><p>
Returns an object that represents an http response which will eventually have a value. This http_get method is invoked asynchronously. Check for completion before attempting to read results.
</p><pre><code class="language-ruby">def tick args
  # perform an http get and print the response when available
  args.state.result ||= args.gtk.http_get "https://httpbin.org/html"

  if args.state.result &amp;&amp; args.state.result[:complete] &amp;&amp; !args.state.printed
    if args.state.result[:http_response_code] == 200
      puts "The response was successful. The body is:"
      puts args.state.result[:response_data]
    else
      puts "The response failed. Status code:"
      puts args.state.result[:http_response_code]
    end
    # set a flag denoting that the response has been printed
    args.state.printed = true

    # show the console
    args.gtk.show_console
  end
end
</code></pre></div><div><h2 id="----http_post-"><code>http_post</code></h2><p>
Returns an object that represents an http response which will eventually have a value. This http_post method is invoked asynchronously. Check for completion before attempting to read results.
</p><ul>
<li>First parameter: The url to send the request to.</li>
<li>Second parameter: Hash that represents form fields to send.</li>
<li>Third parameter: Headers. Note: Content-Type must be form encoded
                   flavor. If you are unsure of what to pass in, set the content type                    to application/x-www-form-urlencoded</li>
</ul><pre><code class="language-ruby">def tick args
  # perform an http get and print the response when available

  args.state.form_fields ||= { "userId" =&gt; "#{Time.now.to_i}" }
  args.state.result ||= args.gtk.http_post "http://httpbin.org/post",
                                           form_fields,
                                           ["Content-Type: application/x-www-form-urlencoded"]


  if args.state.result &amp;&amp; args.state.result[:complete] &amp;&amp; !args.state.printed
    if args.state.result[:http_response_code] == 200
      puts "The response was successful. The body is:"
      puts args.state.result[:response_data]
    else
      puts "The response failed. Status code:"
      puts args.state.result[:http_response_code]
    end
    # set a flag denoting that the response has been printed
    args.state.printed = true

    # show the console
    args.gtk.show_console
  end
end
</code></pre></div><div><h2 id="----http_post_body-"><code>http_post_body</code></h2><p>
Returns an object that represents an http response which will eventually have a value. This http_post_body method is invoked asynchronously. Check for completion before attempting to read results.
</p><ul>
<li>First parameter: The url to send the request to.</li>
<li>Second parameter: String that represents the body that will be sent</li>
<li>Third parameter: Headers. Be sure to populate the Content-Type that
                   matches the data you are sending.</li>
</ul><pre><code class="language-ruby">def tick args
  # perform an http get and print the response when available

  args.state.json ||= "{ "userId": "#{Time.now.to_i}"}"
  args.state.result ||= args.gtk.http_post_body "http://httpbin.org/post",
                                                args.state.json,
                                                ["Content-Type: application/json", "Content-Length: #{args.state.json.length}"]


  if args.state.result &amp;&amp; args.state.result[:complete] &amp;&amp; !args.state.printed
    if args.state.result[:http_response_code] == 200
      puts "The response was successful. The body is:"
      puts args.state.result[:response_data]
    else
      puts "The response failed. Status code:"
      puts args.state.result[:http_response_code]
    end
    # set a flag denoting that the response has been printed
    args.state.printed = true

    # show the console
    args.gtk.show_console
  end
end
</code></pre></div><div><h2 id="----start_server!-"><code>start_server!</code></h2><p>
Starts a in-game http server that can be process http requests. When your game is running in development mode. A dev server is started at <code>http://localhost:9001</code>
</p><p>
You can start an in-game http server in production via:
</p><pre><code class="language-ruby">def tick args
  # server explicitly enabled in production
  args.gtk.start_server! port: 9001, enable_in_prod: true
end
</code></pre><p>
Here's how you would responde to http requests:
</p><pre><code class="language-ruby">def tick args
  # server explicitly enabled in production
  args.gtk.start_server! port: 9001, enable_in_prod: true

  # loop through pending requests and respond to them
  args.inputs.http_requests.each do |request|
    puts "#{request}"
    request.respond 200, "ok"
  end
end
</code></pre></div><div><h2 id="----production--"><code>production?</code></h2><p>
Returns true if the game is being run in a released/shipped state.
</p></div><div><h2 id="----version-"><code>version</code></h2><p>
Returns a string representing the version of DragonRuby you are running.
</p></div><div><h2 id="----version_pro--"><code>version_pro?</code></h2><p>
Returns <code>true</code> if the version of DragonRuby is NOT Standard Edition.
</p></div><div><h2 id="----reset-"><code>reset</code></h2><p>
Resets DragonRuby's internal state as if it were just started. <code>args.state.tick_count</code> is set to <code>0</code> and <code>args.state</code> is cleared of any values. This function is helpful when you are developing your game and want to reset everything as if the game just booted up.
</p><pre><code class="language-ruby">def tick args
end

# reset the game if this file is hotloaded/required
# (removes the need to press "r" when I file is updated)
$gtk.reset
</code></pre><p>
NOTE: <code>args.gtk.reset</code> does not reset global variables or instance of classes you have have constructed.
</p></div><div><h2 id="----reset_next_tick-"><code>reset_next_tick</code></h2><p>
Has the same behavior as <code>reset</code> except the reset occurs before <code>tick</code> is executed again. <code>reset</code> resets the environment immediately (while the <code>tick</code> method is inflight). It's recommended that <code>reset</code> should be called outside of the tick method (invoked when a file is saved/hotloaded), and <code>reset_next_tick</code> be used inside of the <code>tick</code> method so you don't accidentally blow away state the your game depends on to complete the current <code>tick</code> without exceptions.
</p><pre><code class="language-ruby">def tick args
  # reset the game if "r" is pressed on the keyboard
  if args.inputs.keyboard.key_down.r
    args.gtk.reset_next_tick # use reset_next_tick instead of reset
  end
end

# reset the game if this file is hotloaded/required
# (removes the need to press "r" when I file is updated)
$gtk.reset
</code></pre></div><div><h2 id="----reset_sprite-"><code>reset_sprite</code></h2><p>
Sprites when loaded are cached. This method invalidates the cache record of a sprite so that updates on from the disk can be loaded.
</p></div><div><h2 id="----calcspritebox-"><code>calcspritebox</code></h2><p>
Given a path to a sprite, this method returns the <code>width</code> and <code>height</code> of a sprite as a tuple.
</p><p>
NOTE: This method should be used for development purposes only and is       expensive to call every frame. Do not use this method to set the       size of sprite when rendering (hard code those values since you       know what they are beforehand).
</p></div><div><h2 id="----current_framerate-"><code>current_framerate</code></h2><p>
Returns a float value representing the framerate of your game. This is an approximation/moving average of your framerate and should eventually settle to 60fps.
</p><pre><code class="language-ruby">def tick args
  # render a label to the screen that shows the current framerate
  # formatted as a floating point number with two decimal places
  args.outputs.labels &lt;&lt; { x: 30, y: 30.from_top, text: "#{args.gtk.current_framerate.to_sf}" }
end
</code></pre></div><div><h2 id="----framerate_diagnostics_primitives-"><code>framerate_diagnostics_primitives</code></h2><p>
Returns a set of primitives that can be rendered to the screen which provide more detailed information about the speed of your simulation (framerate, draw call count, mouse position, etc).
</p><pre><code class="language-ruby">def tick args
  args.outputs.primitives &lt;&lt; args.gtk.framerate_diagnostics_primitives
end
</code></pre></div><div><h2 id="----warn_array_primitives!-"><code>warn_array_primitives!</code></h2><p>
This function helps you audit your game of usages of array-based primitives. While array-based primitives are simple to create and use, they are slower to process than <code>Hash</code> or <code>Class</code> based primitives.
</p><pre><code class="language-ruby">def tick args
  # enable array based primitives warnings
  args.gtk.warn_array_primitives!

  # array-based primitive elsewhere in code
  # an log message will be posted giving the location of the array
  # based primitive usage
  args.outputs.sprites &lt;&lt; [100, 100, 200, 200, "sprites/square/blue.png"]

  # instead of using array based primitives, migrate to hashes as needed
  args.outputs.sprites &lt;&lt; {
    x: 100,
    y: 100,
    w: 200,
    h: 200, path:
    "sprites/square/blue.png"
  }
end
</code></pre></div><div><h2 id="----benchmark-"><code>benchmark</code></h2><p>
You can use this function to compare the relative performance of methods.
</p><pre><code class="language-ruby">def tick args
  # press r to run benchmark
  if args.inputs.keyboard.key_down.r
    args.gtk.console.show
    args.gtk.benchmark iterations: 1000, # number of iterations
                       # label for experiment
                       using_numeric_map: -&gt; () {
                         # experiment body
                         v = 100.map_with_index do |i|
                           i * 100
                         end
                       },
                       # label for experiment
                       using_numeric_times: -&gt; () {
                         # experiment body
                         v = []
                         100.times do |i|
                           v &lt;&lt; i * 100
                         end
                       }
  end
end
</code></pre></div><div><h2 id="----notify!-"><code>notify!</code></h2><p>
Given a string, this function will present a message at the bottom of your game. This method is only invoked in dev mode and is useful for debugging.
</p><p>
An optional parameter of duration (number value representing ticks) can also be passed in. The default value if <code>300</code> ticks (5 seconds).
</p><pre><code class="language-ruby">def tick args
  if args.inputs.mouse.click
    args.gtk.notify! "Mouse was clicked!"
  end

  if args.inputs.keyboard.key_down.r
    # optional duration parameter
    args.gtk.notify! "R key was pressed!", 600 # present message for 10 seconds/600 frames
  end
end
</code></pre></div><div><h2 id="----notify_extended!-"><code>notify_extended!</code></h2><p>
Has similar behavior as notify! except you have additional options to show messages in a production environment.
</p><pre><code class="language-ruby">def tick args
  if args.inputs.mouse.click
    args.gtk.notify_extended! message: "message",
                              duration: 300,
                              env: :prod
  end
end
</code></pre></div><div><h2 id="----slowmo!-"><code>slowmo!</code></h2><p>
Given a numeric value representing the factor of 60fps. This function will bring your simulation loop down to slower rate. This method is intended to be used for debugging purposes.
</p><pre><code class="language-ruby">def tick args
  # set your simulation speed to (15 fps): args.gtk.slowmo! 4
  # set your simulation speed to (1 fps): args.gtk.slowmo! 60
  # set your simulation speed to (30 fps):
  args.gtk.slowmo! 2
end
</code></pre><p>
Remove this line from your tick method will automatically set your simulation speed back to 60 fps.
</p></div><div><h2 id="----show_console-"><code>show_console</code></h2><p>
Shows the DragonRuby console. Useful when debugging/customizing an in-game dev workflow.
</p></div><div><h2 id="----hide_console-"><code>hide_console</code></h2><p>
Shows the DragonRuby console. Useful when debugging/customizing an in-game dev workflow.
</p></div><div><h2 id="----enable_console-"><code>enable_console</code></h2><p>
Enables the DragonRuby Console so that it can be presented by pressing the tilde key (the key next to the number 1 key).
</p></div><div><h2 id="----disable_console-"><code>disable_console</code></h2><p>
Disables the DragonRuby Console so that it won't show up even if you press the tilde key or call <code>args.gtk.show_console</code>.
</p></div><div><h2 id="----start_recording-"><code>start_recording</code></h2><p>
Resets the game to tick <code>0</code> and starts recording gameplay. Useful for visual regression tests/verification.
</p></div><div><h2 id="----stop_recording-"><code>stop_recording</code></h2><p>
Function takes in a destination file for the currently recording gameplay. This file can be used to replay a recording.
</p></div><div><h2 id="----cancel_recording-"><code>cancel_recording</code></h2><p>
Function cancels a gameplay recording session and discards the replay.
</p></div><div><h2 id="----start_replay-"><code>start_replay</code></h2><p>
Given a file that represents a recording, this method will run the recording against the current codebase.
</p><p>
You can start a replay from the command line also:
</p><pre><code class="language-ruby">first argument: the game directory
--replay switch is the file path relative to the game directory
--speed switch is optional. a value of 4 will run the replay and game at 4x speed
cli command example is in the context of Linux and Mac, for Windows the binary would be ./dragonruby.exe
dragonruby ./mygame --replay ./replay.txt --speed 4
</code></pre></div><div><h2 id="----stop_replay-"><code>stop_replay</code></h2><p>
Function stops a replay that is currently executing.
</p></div><div><h2 id="----get_base_dir-"><code>get_base_dir</code></h2><p>
Returns the path to the location of the dragonruby binary. In production mode, this value will be the same as the value returned by <code>get_game_dir</code>. Function should only be used for debugging/development workflows.
</p></div><div><h2 id="----get_game_dir-"><code>get_game_dir</code></h2><p>
Returns the location within sandbox storage that the game is running. When developing your game, this value will be your <code>mygame</code> directory. In production, it'll return a value that is OS specific (eg the Roaming directory on Windows or the Application Support directory on Mac).
</p><p>
Invocations of ~(write|append)_file will write to this sandboxed directory.
</p></div><div><h2 id="----get_game_dir_url-"><code>get_game_dir_url</code></h2><p>
Returns a url encoded string representing the sandbox location for game data.
</p></div><div><h2 id="----open_game_dir-"><code>open_game_dir</code></h2><p>
Opens the game directory in the OS's file explorer. This should be used for debugging purposes only.
</p></div><div><h2 id="----write_file_root-"><code>write_file_root</code></h2><p>
Given a file path and contents, the contents will be written to a directory outside of the game directory. This method should be used for development purposes only. In production this method will write to the same sandboxed location as <code>write_file</code>.
</p></div><div><h2 id="----append_file_root-"><code>append_file_root</code></h2><p>
Has the same behavior as <code>write_file_root</code> except that it appends the contents as opposed to overwriting them.
</p></div><div><h2 id="----argv-"><code>argv</code></h2><p>
Returns a string representing the command line arguments passed to the DragonRuby binary. This should be used for development/debugging purposes only.
</p></div><div><h2 id="----cli_arguments-"><code>cli_arguments</code></h2><p>
Returns a <code>Hash</code> for command line arguments in the format of <code>--switch value</code> (two hyphens preceding the switch flag with the value seperated by a space). This should be used for development/debugging purposes only.
</p></div><div><h2 id="----reload_history-"><code>reload_history</code></h2><p>
Returns a <code>Hash</code> representing the code files that have be loaded for your game along with timings for the events. This should be used for development/debugging purposes only.
</p></div><div><h2 id="----reload_history_pending-"><code>reload_history_pending</code></h2><p>
Returns a <code>Hash</code> for files that have been queued for reload, but haven't been processed yet. This should be used for development/debugging purposes only.
</p></div><div><h2 id="----reload_if_needed-"><code>reload_if_needed</code></h2><p>
Given a file name, this function will queue the file for reload if it's been modified. An optional second parameter can be passed in to signify if the file should be forced loaded regardless of modified time (<code>true</code> means to force load, <code>false</code> means to load only if the file has been modified). This function should be used for development/debugging purposes only.
</p></div></div><div id="section---args-state-"><h1 id="---args-state-"><code>args.state</code></h1><p>
Store your game state inside of this <code>state</code>. Properties with arbitrary nesting is allowed and a backing Entity will be created on your behalf.
</p><pre><code class="language-ruby">def tick args
  args.state.player.x ||= 0
  args.state.player.y ||= 0
end
</code></pre><div><h2 id="----args-state---entity_id-"><code>args.state.*.entity_id</code></h2><p>
Entities automatically receive an <code>entity_id</code> of type <code>Fixnum</code>.
</p></div><div><h2 id="----args-state---entity_type-"><code>args.state.*.entity_type</code></h2><p>
Entities can have an <code>entity_type</code> which is represented as a <code>Symbol</code>.
</p></div><div><h2 id="----args-state---created_at-"><code>args.state.*.created_at</code></h2><p>
Entities have <code>created_at</code> set to <code>args.state.tick_count</code> when they are created.
</p></div><div><h2 id="----args-state---created_at_elapsed-"><code>args.state.*.created_at_elapsed</code></h2><p>
Returns the elapsed number of ticks since creation.
</p></div><div><h2 id="----args-state---global_created_at-"><code>args.state.*.global_created_at</code></h2><p>
Entities have <code>global_created_at</code> set to <code>Kernel.global_tick_count</code> when they are created.
</p></div><div><h2 id="----args-state---global_created_at_elapsed-"><code>args.state.*.global_created_at_elapsed</code></h2><p>
Returns the elapsed number of global ticks since creation.
</p></div><div><h2 id="----args-state---as_hash-"><code>args.state.*.as_hash</code></h2><p>
Entity cast to a <code>Hash</code> so you can update values as if you were updating a <code>Hash</code>.
</p></div><div><h2 id="----args-state-new_entity-"><code>args.state.new_entity</code></h2><p>
Creates a new Entity with a <code>type</code>, and initial properties. An option block can be passed to change the newly created entity:
</p><pre><code class="language-ruby">def tick args
  args.state.player ||= args.state.new_entity :player, x: 0, y: 0 do |e|
    e.max_hp = 100
    e.hp     = e.max_hp * rand
  end
end
</code></pre></div><div><h2 id="----args-state-new_entity_strict-"><code>args.state.new_entity_strict</code></h2><p>
Creates a new Strict Entity. While Entities created via <code>args.state.new_entity</code> can have new properties added later on, Entities created using <code>args.state.new_entity</code> must define all properties that are allowed during its initialization. Attempting to add new properties after initialization will result in an exception.
</p></div><div><h2 id="----args-state-tick_count-"><code>args.state.tick_count</code></h2><p>
Returns the current tick of the game. <code>args.state.tick_count</code> is <code>0</code> when the game is first started or if the game is reset via <code>$gtk.reset</code>.
</p></div></div><div id="section---args-inputs-"><h1 id="---args-inputs-"><code>args.inputs</code></h1><p>
Access using input using <code>args.inputs</code>.
</p><div><h2 id="----args-inputs-up-"><code>args.inputs.up</code></h2><p>
Returns <code>true</code> if: the <code>up</code> arrow or <code>w</code> key is pressed or held on the <code>keyboard</code>; or if <code>up</code> is pressed or held on <code>controller_one</code>; or if the <code>left_analog</code> on <code>controller_one</code> is tilted upwards.
</p></div><div><h2 id="----args-inputs-down-"><code>args.inputs.down</code></h2><p>
Returns <code>true</code> if: the <code>down</code> arrow or <code>s</code> key is pressed or held on the <code>keyboard</code>; or if <code>down</code> is pressed or held on <code>controller_one</code>; or if the <code>left_analog</code> on <code>controller_one</code> is tilted downwards.
</p></div><div><h2 id="----args-inputs-left-"><code>args.inputs.left</code></h2><p>
Returns <code>true</code> if: the <code>left</code> arrow or <code>a</code> key is pressed or held on the <code>keyboard</code>; or if <code>left</code> is pressed or held on <code>controller_one</code>; or if the <code>left_analog</code> on <code>controller_one</code> is tilted to the left.
</p></div><div><h2 id="----args-inputs-right-"><code>args.inputs.right</code></h2><p>
Returns <code>true</code> if: the <code>right</code> arrow or <code>d</code> key is pressed or held on the <code>keyboard</code>; or if <code>right</code> is pressed or held on <code>controller_one</code>; or if the <code>left_analog</code> on <code>controller_one</code> is tilted to the right.
</p></div><div><h2 id="----args-inputs-left_right-"><code>args.inputs.left_right</code></h2><p>
Returns <code>-1</code> (left), <code>0</code> (neutral), or <code>+1</code> (right) depending on results of <code>args.inputs.left</code> and <code>args.inputs.right</code>.
</p><pre><code class="language-ruby">args.state.player[:x] += args.inputs.left_right * args.state.speed
</code></pre></div><div><h2 id="----args-inputs-up_down-"><code>args.inputs.up_down</code></h2><p>
Returns <code>-1</code> (down), <code>0</code> (neutral), or <code>+1</code> (up) depending on results of <code>args.inputs.down</code> and <code>args.inputs.up</code>.
</p><pre><code class="language-ruby">args.state.player[:y] += args.inputs.up_down * args.state.speed
</code></pre></div><div><h2 id="----args-inputs-text--or--args-inputs-history-"><code>args.inputs.text</code> OR <code>args.inputs.history</code></h2><p>
Returns a string that represents the last key that was pressed on the keyboard.
</p></div><div><h2 id="----args-inputs-mouse-"><code>args.inputs.mouse</code></h2><p>
Represents the user's mouse.
</p><h3 id="-----args-inputs-mouse-has_focus-"><code>args.inputs.mouse.has_focus</code></h3><p>
Return's true if the game has mouse focus.
</p><h3 id="-----args-inputs-mouse-x-"><code>args.inputs.mouse.x</code></h3><p>
Returns the current <code>x</code> location of the mouse.
</p><h3 id="-----args-inputs-mouse-y-"><code>args.inputs.mouse.y</code></h3><p>
Returns the current <code>y</code> location of the mouse.
</p><h3 id="-----args-inputs-mouse-inside_rect--rect-"><code>args.inputs.mouse.inside_rect? rect</code></h3><p>
Return. <code>args.inputs.mouse.inside_rect?</code> takes in any primitive that responds to <code>x, y, w, h</code>:
</p><h3 id="-----args-inputs-mouse-inside_circle--center_point--radius-"><code>args.inputs.mouse.inside_circle? center_point, radius</code></h3><p>
Returns <code>true</code> if the mouse is inside of a specified circle. <code>args.inputs.mouse.inside_circle?</code> takes in any primitive that responds to <code>x, y</code> (which represents the circle's center), and takes in a <code>radius</code>:
</p><h3 id="-----args-inputs-mouse-moved-"><code>args.inputs.mouse.moved</code></h3><p>
Returns <code>true</code> if the mouse has moved on the current frame.
</p><h3 id="-----args-inputs-mouse-button_left-"><code>args.inputs.mouse.button_left</code></h3><p>
Returns <code>true</code> if the left mouse button is down.
</p><h3 id="-----args-inputs-mouse-button_middle-"><code>args.inputs.mouse.button_middle</code></h3><p>
Returns <code>true</code> if the middle mouse button is down.
</p><h3 id="-----args-inputs-mouse-button_right-"><code>args.inputs.mouse.button_right</code></h3><p>
Returns <code>true</code> if the right mouse button is down.
</p><h3 id="-----args-inputs-mouse-button_bits-"><code>args.inputs.mouse.button_bits</code></h3><p>
Returns a bitmask for all buttons on the mouse: <code>1</code> for a button in the <code>down</code> state, <code>0</code> for a button in the <code>up</code> state.
</p><h3 id="-----args-inputs-mouse-wheel-"><code>args.inputs.mouse.wheel</code></h3><p>
Represents the mouse wheel. Returns <code>nil</code> if no mouse wheel actions occurred.
</p><h3 id="-----args-inputs-mouse-wheel-x-"><code>args.inputs.mouse.wheel.x</code></h3><p>
Returns the negative or positive number if the mouse wheel has changed in the <code>x</code> axis.
</p><h3 id="-----args-inputs-mouse-wheel-y-"><code>args.inputs.mouse.wheel.y</code></h3><p>
Returns the negative or positive number if the mouse wheel has changed in the <code>y</code> axis.
</p><h3 id="-----args-inputs-mouse-click--or---down-----previous_click-----up-"><code>args.inputs.mouse.click</code> OR <code>.down</code>, <code>.previous_click</code>, <code>.up</code></h3><p>
The properties <code>args.inputs.mouse.(click|down|previous_click|up)</code> each return <code>nil</code> if the mouse button event didn't occur. And return an Entity that has an <code>x</code>, <code>y</code> properties along with helper functions to determine collision: <code>inside_rect?</code>, <code>inside_circle</code>.
</p></div><div><h2 id="----args-inputs-controller_(one-four)-"><code>args.inputs.controller_(one-four)</code></h2><p>
Represents controllers connected to the usb ports.
</p><h3 id="-----args-inputs-controller_(one-four)-up-"><code>args.inputs.controller_(one-four).up</code></h3><p>
Returns <code>true</code> if <code>up</code> is pressed or held on the directional or left analog.
</p><h3 id="-----args-inputs-controller_(one-four)-down-"><code>args.inputs.controller_(one-four).down</code></h3><p>
Returns <code>true</code> if <code>down</code> is pressed or held on the directional or left analog.
</p><h3 id="-----args-inputs-controller_(one-four)-left-"><code>args.inputs.controller_(one-four).left</code></h3><p>
Returns <code>true</code> if <code>left</code> is pressed or held on the directional or left analog.
</p><h3 id="-----args-inputs-controller_(one-four)-right-"><code>args.inputs.controller_(one-four).right</code></h3><p>
Returns <code>true</code> if <code>right</code> is pressed or held on the directional or left analog.
</p><h3 id="-----args-inputs-controller_(one-four)-left_right-"><code>args.inputs.controller_(one-four).left_right</code></h3><p>
Returns <code>-1</code> (left), <code>0</code> (neutral), or <code>+1</code> (right) depending on results of <code>args.inputs.controller_(one-four).left</code> and <code>args.inputs.controller_(one-four).right</code>.
</p><h3 id="-----args-inputs-controller_(one-four)-up_down-"><code>args.inputs.controller_(one-four).up_down</code></h3><p>
Returns <code>-1</code> (down), <code>0</code> (neutral), or <code>+1</code> (up) depending on results of <code>args.inputs.controller_(one-four).up</code> and <code>args.inputs.controller_(one-four).down</code>.
</p><h3 id="-----args-inputs-controller_(one-four)-(left_analog_x_raw|right_analog_x_raw)-"><code>args.inputs.controller_(one-four).(left_analog_x_raw|right_analog_x_raw)</code></h3><p>
Returns the raw integer value for the analog's horizontal movement (<code>-32,000 to +32,000</code>).
</p><h3 id="-----args-inputs-controller_(one-four)-left_analog_y_raw|right_analog_y_raw)-"><code>args.inputs.controller_(one-four).left_analog_y_raw|right_analog_y_raw)</code></h3><p>
Returns the raw integer value for the analog's vertical movement (<code>-32,000 to +32,000</code>).
</p><h3 id="-----args-inputs-controller_(one-four)-left_analog_x_perc|right_analog_x_perc)-"><code>args.inputs.controller_(one-four).left_analog_x_perc|right_analog_x_perc)</code></h3><p>
Returns a number between <code>-1</code> and <code>1</code> which represents the percentage the analog is moved horizontally as a ratio of the maximum horizontal movement.
</p><h3 id="-----args-inputs-controller_(one-four)-left_analog_y_perc|right_analog_y_perc)-"><code>args.inputs.controller_(one-four).left_analog_y_perc|right_analog_y_perc)</code></h3><p>
Returns a number between <code>-1</code> and <code>1</code> which represents the percentage the analog is moved vertically as a ratio of the maximum vertical movement.
</p><h3 id="-----args-inputs-controller_(one-four)-directional_up-"><code>args.inputs.controller_(one-four).directional_up</code></h3><p>
Returns <code>true</code> if <code>up</code> is pressed or held on the directional.
</p><h3 id="-----args-inputs-controller_(one-four)-directional_down-"><code>args.inputs.controller_(one-four).directional_down</code></h3><p>
Returns <code>true</code> if <code>down</code> is pressed or held on the directional.
</p><h3 id="-----args-inputs-controller_(one-four)-directional_left-"><code>args.inputs.controller_(one-four).directional_left</code></h3><p>
Returns <code>true</code> if <code>left</code> is pressed or held on the directional.
</p><h3 id="-----args-inputs-controller_(one-four)-directional_right-"><code>args.inputs.controller_(one-four).directional_right</code></h3><p>
Returns <code>true</code> if <code>right</code> is pressed or held on the directional.
</p><h3 id="-----args-inputs-controller_(one-four)-(a|b|x|y|l1|r1|l2|r2|l3|r3|start|select)-"><code>args.inputs.controller_(one-four).(a|b|x|y|l1|r1|l2|r2|l3|r3|start|select)</code></h3><p>
Returns <code>true</code> if the specific button is pressed or held.
</p><h3 id="-----args-inputs-controller_(one-four)-truthy_keys-"><code>args.inputs.controller_(one-four).truthy_keys</code></h3><p>
Returns a collection of <code>Symbol</code>s that represent all keys that are in the pressed or held state.
</p><h3 id="-----args-inputs-controller_(one-four)-key_down-"><code>args.inputs.controller_(one-four).key_down</code></h3><p>
Returns <code>true</code> if the specific button was pressed on this frame. <code>args.inputs.controller_(one-four).key_down.BUTTON</code> will only be true on the frame it was pressed.
</p><h3 id="-----args-inputs-controller_(one-four)-key_held-"><code>args.inputs.controller_(one-four).key_held</code></h3><p>
Returns <code>true</code> if the specific button is being held. <code>args.inputs.controller_(one-four).key_held.BUTTON</code> will be true for all frames after <code>key_down</code> (until released).
</p><h3 id="-----args-inputs-controller_(one-four)-key_up-"><code>args.inputs.controller_(one-four).key_up</code></h3><p>
Returns <code>true</code> if the specific button was released. <code>args.inputs.controller_(one-four).key_up.BUTTON</code> will be true only on the frame the button was released.
</p></div><div><h2 id="----args-inputs-keyboard-"><code>args.inputs.keyboard</code></h2><p>
Represents the user's keyboard
</p><h3 id="-----args-inputs-keyboard-has_focus-"><code>args.inputs.keyboard.has_focus</code></h3><p>
Returns <code>true</code> if the game has keyboard focus.
</p><h3 id="-----args-inputs-keyboard-up-"><code>args.inputs.keyboard.up</code></h3><p>
Returns <code>true</code> if <code>up</code> or <code>w</code> is pressed or held on the keyboard.
</p><h3 id="-----args-inputs-keyboard-down-"><code>args.inputs.keyboard.down</code></h3><p>
Returns <code>true</code> if <code>down</code> or <code>s</code> is pressed or held on the keyboard.
</p><h3 id="-----args-inputs-keyboard-left-"><code>args.inputs.keyboard.left</code></h3><p>
Returns <code>true</code> if <code>left</code> or <code>a</code> is pressed or held on the keyboard.
</p><h3 id="-----args-inputs-keyboard-right-"><code>args.inputs.keyboard.right</code></h3><p>
Returns <code>true</code> if <code>right</code> or <code>d</code> is pressed or held on the keyboard.
</p><h3 id="-----args-inputs-keyboard-left_right-"><code>args.inputs.keyboard.left_right</code></h3><p>
Returns <code>-1</code> (left), <code>0</code> (neutral), or <code>+1</code> (right) depending on results of <code>args.inputs.keyboard.left</code> and <code>args.inputs.keyboard.right</code>.
</p><h3 id="-----args-inputs-keyboard-up_down-"><code>args.inputs.keyboard.up_down</code></h3><p>
Returns <code>-1</code> (left), <code>0</code> (neutral), or <code>+1</code> (right) depending on results of <code>args.inputs.keyboard.up</code> and <code>args.inputs.keyboard.up</code>.
</p><h3 id="----keyboard-properties">keyboard properties</h3><p>
The following properties represent keys on the keyboard and are available on <code>args.inputs.keyboard.KEY</code>, <code>args.inputs.keyboard.key_down.KEY</code>, <code>args.inputs.keyboard.key_held.KEY</code>, and <code>args.inputs.keyboard.key_up.KEY</code>:
</p><ul>
<li><code>alt</code></li>
<li><code>meta</code></li>
<li><code>control</code></li>
<li><code>shift</code></li>
<li><code>ctrl_KEY</code> (dynamic method, eg <code>args.inputs.keyboard.ctrl_a</code>)</li>
<li><code>exclamation_point</code></li>
<li><code>zero</code> - <code>nine</code></li>
<li><code>backspace</code></li>
<li><code>delete</code></li>
<li><code>escape</code></li>
<li><code>enter</code></li>
<li><code>tab</code></li>
<li><code>(open|close)_round_brace</code></li>
<li><code>(open|close)_curly_brace</code></li>
<li><code>(open|close)_square_brace</code></li>
<li><code>colon</code></li>
<li><code>semicolon</code></li>
<li><code>equal_sign</code></li>
<li><code>hyphen</code></li>
<li><code>space</code></li>
<li><code>dollar_sign</code></li>
<li><code>double_quotation_mark</code></li>
<li><code>single_quotation_mark</code></li>
<li><code>backtick</code></li>
<li><code>tilde</code></li>
<li><code>period</code></li>
<li><code>comma</code></li>
<li><code>pipe</code></li>
<li><code>underscore</code></li>
<li><code>a</code> - <code>z</code></li>
<li><code>shift</code></li>
<li><code>control</code></li>
<li><code>alt</code></li>
<li><code>meta</code></li>
<li><code>left</code></li>
<li><code>right</code></li>
<li><code>up</code></li>
<li><code>down</code></li>
<li><code>pageup</code></li>
<li><code>pagedown</code></li>
<li><code>char</code></li>
<li><code>plus</code></li>
<li><code>at</code></li>
<li><code>forward_slash</code></li>
<li><code>back_slash</code></li>
<li><code>asterisk</code></li>
<li><code>less_than</code></li>
<li><code>greater_than</code></li>
<li><code>carat</code></li>
<li><code>ampersand</code></li>
<li><code>superscript_two</code></li>
<li><code>circumflex</code></li>
<li><code>question_mark</code></li>
<li><code>section_sign</code></li>
<li><code>ordinal_indicator</code></li>
<li><code>raw_key</code></li>
<li><code>left_right</code></li>
<li><code>up_down</code></li>
<li><code>directional_vector</code></li>
<li><code>truthy_keys</code></li>
</ul><h3 id="-----inputs-keyboard-keys-"><code>inputs.keyboard.keys</code></h3><p>
Returns a <code>Hash</code> with all keys on the keyboard in their respective state. The <code>Hash</code> contains the following <code>keys</code>
</p><ul>
<li><code>:down</code></li>
<li><code>:held</code></li>
<li><code>:down_or_held</code></li>
<li><code>:up</code></li>
</ul></div><div><h2 id="----args-inputs-touch-"><code>args.inputs.touch</code></h2><p>
Returns a <code>Hash</code> representing all touch points on a touch device. This api is only available in Indie, and Pro versions.
</p></div><div><h2 id="----args-inputs-finger_left-"><code>args.inputs.finger_left</code></h2><p>
Returns a <code>Hash</code> with <code>x</code> and <code>y</code> denoting a touch point that is on the left side of the screen. This api is only available in Indie, and Pro versions.
</p></div><div><h2 id="----args-inputs-finger_right-"><code>args.inputs.finger_right</code></h2><p>
Returns a <code>Hash</code> with <code>x</code> and <code>y</code> denoting a touch point that is on the right side of the screen. This api is only available in Indie, and Pro versions.
</p></div></div><div id="section---args-outputs-"><h1 id="---args-outputs-"><code>args.outputs</code></h1><p>
Outputs is how you render primitives to the screen. The minimal setup for rendering something to the screen is via a <code>tick</code> method defined in mygame/app/main.rb
</p><pre><code class="language-ruby">def tick args
  args.outputs.solids     &lt;&lt; [0, 0, 100, 100]
  args.outputs.sprites    &lt;&lt; [100, 100, 100, 100, "sprites/square/blue.png"]
  args.outputs.labels     &lt;&lt; [200, 200, "Hello World"]
  args.outputs.lines      &lt;&lt; [300, 300, 400, 400]
end
</code></pre><p>
Primitives are rendered first-in, first-out. The rendering order (sorted by bottom-most to top-most):
</p><ul>
<li><code>solids</code></li>
<li><code>sprites</code></li>
<li><code>primitives</code>: Accepts all render primitives. Useful when you want to bypass the default rendering orders for rendering (eg. rendering solids on top of sprites).</li>
<li><code>labels</code></li>
<li><code>lines</code></li>
<li><code>borders</code></li>
<li><code>debug</code>: Accepts all render primitives. Use this to render primitives for debugging (production builds of your game will not render this layer).</li>
</ul><div><h2 id="----args-outputs-background_color-"><code>args.outputs.background_color</code></h2><p>
Set <code>args.outputs.background_color</code> to an <code>Array</code> with <code>RGB</code> values (eg. <code>[255, 255, 255]</code> for the color white).
</p></div><div><h2 id="----args-outputs-sounds-"><code>args.outputs.sounds</code></h2><p>
Send a file path to this collection to play a sound. The sound file must be under the <code>mygame</code> directory.
</p><pre><code class="language-ruby">args.outputs.sounds &lt;&lt; "sounds/jump.wav"
</code></pre></div><div><h2 id="----args-outputs-solids-"><code>args.outputs.solids</code></h2><p>
Send a Primitive to this collection to render a filled in rectangle to the screen. This collection is cleared at the end of every frame.
</p></div><div><h2 id="----args-outputs-static_solids-"><code>args.outputs.static_solids</code></h2><p>
Send a Primitive to this collection to render a filled in rectangle to the screen. This collection is not cleared at the end of every frame. And objects can be mutated by reference.
</p></div><div><h2 id="----args-outputs-sprites-----static_sprites-"><code>args.outputs.sprites</code>, <code>.static_sprites</code></h2><p>
Send a Primitive to this collection to render a sprite to the screen.
</p></div><div><h2 id="----args-outputs-primitives-----static_primitives-"><code>args.outputs.primitives</code>, <code>.static_primitives</code></h2><p>
Send a Primitive of any type and it'll be rendered. The Primitive must have a <code>primitive_marker</code> that returns <code>:solid</code>, <code>:sprite</code>, <code>:label</code>, <code>:line</code>, <code>:border</code>.
</p></div><div><h2 id="----args-outputs-labels-----static_labels-"><code>args.outputs.labels</code>, <code>.static_labels</code></h2><p>
Send a Primitive to this collection to render text to the screen.
</p></div><div><h2 id="----args-outputs-lines-----static_lines-"><code>args.outputs.lines</code>, <code>.static_lines</code></h2><p>
Send a Primitive to this collection to render a line to the screen.
</p></div><div><h2 id="----args-outputs-borders-----static_borders-"><code>args.outputs.borders</code>, <code>.static_borders</code></h2><p>
Send a Primitive to this collection to render an unfilled rectangle to the screen.
</p></div><div><h2 id="----args-outputs-debug-----static_debug-"><code>args.outputs.debug</code>, <code>.static_debug</code></h2><p>
Send any Primitive to this collection which represents things you render to the screen for debugging purposes. Primitives in this collection will not be rendered in a production release of your game.
</p></div></div><div id="section---args-easing-"><h1 id="---args-easing-"><code>args.easing</code></h1><p>
A set of functions that allow you to determine the current progression of an easing function.
</p><div><h2 id="----args-easing-ease-start_tick--current_tick--duration--easing_functions-"><code>args.easing.ease start_tick, current_tick, duration, easing_functions</code></h2><p>
Given a start, current, duration, and easing function names, <code>ease</code> returns a number between 0 and 1 that represents the progress of an easing function.
</p><p>
The built in easing definitions you have access to are <code>:identity</code>, <code>:flip</code>, <code>:quad</code>, <code>:cube</code>, <code>:quart</code>, and <code>:quint</code>.
</p><p>
This example will move a box at a linear speed from 0 to 1280.
</p><pre><code class="language-ruby">def tick args
  start_time = 10
  duration = 60
  current_progress = args.easing.ease start_time,
                                      args.state.tick_count,
                                      duration,
                                      :identity
  args.outputs.solids &lt;&lt; { x: 1280 * current_progress, y: 360, w: 10, h: 10 }
end
</code></pre></div><div><h2 id="----args-easing-ease_spline-start_tick--current_tick--duration--spline-"><code>args.easing.ease_spline start_tick, current_tick, duration, spline</code></h2><p>
Given a start, current, duration, and a multiple bezier values, this function returns a number between 0 and 1 that represents the progress of an easing function.
</p><p>
This example will move a box at a linear speed from 0 to 1280 and then back to 0 using two bezier definitions (represented as an array with four values).
</p><pre><code class="language-ruby">def tick args
  start_time = 10
  duration = 60
  spline = [
    [  0, 0.25, 0.75, 1.0],
    [1.0, 0.75, 0.25,   0]
  ]
  current_progress = args.easing.ease_spline start_time,
                                             args.state.tick_count,
                                             duration,
                                             spline
  args.outputs.solids &lt;&lt; { x: 1280 * current_progress, y: 360, w: 10, h: 10 }
end
</code></pre></div></div><div id="section---args-string-"><h1 id="---args-string-"><code>args.string</code></h1><p>
Useful string functions not included in Ruby core libraries.
</p><div><h2 id="----args-string-wrapped_lines-string--max_character_length-"><code>args.string.wrapped_lines string, max_character_length</code></h2><p>
This function will return a collection of strings given an input <code>string</code> and <code>max_character_length</code>. The collection of strings returned will split the input string into strings of <code>length &lt;= max_character_length</code>.
</p><p>
The following example takes a string with new lines and creates a label for each one. Labels (<code>args.outputs.labels</code>) ignore newline characters <code>\n</code>.
</p><pre><code class="language-ruby">def tick args
  long_string = "Lorem ipsum dolor sit amet, consectetur adipiscing elit.
teger dolor velit, ultricies vitae libero vel, aliquam imperdiet enim."
  max_character_length = 30
  long_strings_split = args.string.wrapped_lines long_string, max_character_length
  args.outputs.labels &lt;&lt; long_strings_split.map_with_index do |s, i|
    { x: 10, y: 600 - (i * 20), text: s }
  end
end
</code></pre></div></div><div id="section---args-grid-"><h1 id="---args-grid-"><code>args.grid</code></h1><p>
Returns the virtual grid for the game.
</p><div><h2 id="----args-grid-name-"><code>args.grid.name</code></h2><p>
Returns either <code>:origin_bottom_left</code> or <code>:origin_center</code>.
</p></div><div><h2 id="----args-grid-bottom-"><code>args.grid.bottom</code></h2><p>
Returns the <code>y</code> value that represents the bottom of the grid.
</p></div><div><h2 id="----args-grid-top-"><code>args.grid.top</code></h2><p>
Returns the <code>y</code> value that represents the top of the grid.
</p></div><div><h2 id="----args-grid-left-"><code>args.grid.left</code></h2><p>
Returns the <code>x</code> value that represents the left of the grid.
</p></div><div><h2 id="----args-grid-right-"><code>args.grid.right</code></h2><p>
Returns the <code>x</code> value that represents the right of the grid.
</p></div><div><h2 id="----args-grid-rect-"><code>args.grid.rect</code></h2><p>
Returns a rectangle Primitive that represents the grid.
</p></div><div><h2 id="----args-grid-origin_bottom_left!-"><code>args.grid.origin_bottom_left!</code></h2><p>
Change the grids coordinate system to 0, 0 at the bottom left corner.
</p></div><div><h2 id="----args-grid-origin_center!-"><code>args.grid.origin_center!</code></h2><p>
Change the grids coordinate system to 0, 0 at the center of the screen.
</p></div><div><h2 id="----args-grid-w-"><code>args.grid.w</code></h2><p>
Returns the grid's width (always 1280).
</p></div><div><h2 id="----args-grid-h-"><code>args.grid.h</code></h2><p>
Returns the grid's height (always 720).
</p></div></div><div id="section---audio-"><h1 id="---audio-"><code>Audio</code></h1><p>
Hash that contains audio sources that are playing. If you want to add a new sound add a hash with keys/values as in the following example:
</p><pre><code class="language-ruby">def tick args
  # The values below (except for input of course) are the default values that apply if you don't
  # specify the value in the hash.
  args.audio[:my_audio] = {
    input: 'sound/boom.wav',  # Filename
    x: 0.0, y: 0.0, z: 0.0,   # Relative position to the listener, x, y, z from -1.0 to 1.0
    gain: 1.0,                # Volume (0.0 to 1.0)
    pitch: 1.0,               # Pitch of the sound (1.0 = original pitch)
    paused: false,            # Set to true to pause the sound at the current playback position
    looping: false,           # Set to true to loop the sound/music until you stop it
  }
end
</code></pre><p>
Sounds that don't specify <code>looping: true</code> will be removed automatically from the hash after the playback ends. Looping sounds or sounds that should stop early must be removed manually.
</p><p>
When you assign a hash to an audio output, a <code>:length</code> key will be added to the hash on the following tick. This will tell you the duration of the audio file in seconds (float).
</p><div><h2 id="---audio-synthesis-(pro-only)">Audio synthesis (Pro only)</h2><p>
Instead of a path to an audio file you can specify an array <code>[channels, sample_rate, sound_source]</code> for <code>input</code> to procedurally generate sound. You do this by providing an array of float values between -1.0 and 1.0 that describe the waveform you want to play.
</p><ul>
<li><code>channels</code> is the number of channels: 1 = mono, 2 = stereo</li>
<li><code>sample_rate</code> is the number of values per seconds you will provide to describe the audio wave</li>
<li><code>sound_source</code> The source of your sound. See below</li>
</ul><h3 id="----sound-source">Sound source</h3><p>
A sound source can be one of two things:
</p><ul>
<li>A <code>Proc</code> object that is called on demand to generate the next samples to play. Every call should generate
  enough samples for at least 0.1 to 0.5 seconds to get continuous playback without audio skips.   The audio will continue playing endlessly until removed, so the <code>looping</code> option will have no effect.</li>
<li>An array of sample values that will be played back once. This is useful for procedurally generated one-off SFX.
  <code>looping</code> will work as expected</li>
</ul><p>
When you specify 2 for <code>channels</code>, then the generated sample array will be played back in an interleaved manner. The first element is the first sample for the left channel, the second element is the first sample for the right channel, the third element is the second sample for the left channel etc.
</p><h3 id="----example-">Example:</h3><pre><code class="language-ruby">def tick args
  sample_rate = 48000

  generate_sine_wave = lambda do
    frequency = 440.0 # A5
    samples_per_period = (sample_rate / frequency).ceil
    one_period = samples_per_period.map_with_index { |i|
      Math.sin((2 * Math::PI) * (i / samples_per_period))
    }
    one_period * frequency # Generate 1 second worth of sound
  end

  args.audio[:my_audio] ||= {
    input: [1, sample_rate, generate_sine_wave]
  }
end
</code></pre></div></div><div id="section---easing-"><h1 id="---easing-"><code>Easing</code></h1><p>
This function will give you a float value between <code>0</code> and <code>1</code> that represents a percentage. You need to give the funcation a <code>start_tick</code>, <code>current_tick</code>, duration, and easing <code>definitions</code>.
</p><p>
This YouTube video is a fantastic introduction to easing functions: <a href="https://www.youtube.com/watch?v=mr5xkf6zSzk">https://www.youtube.com/watch?v=mr5xkf6zSzk</a>
</p><div><h2 id="---example">Example</h2><p>
This example shows how to fade in a label at frame 60 over two seconds (120 ticks). The <code>:identity</code> definition implies a linear fade: <code>f(x) -&gt; x</code>.
</p><pre><code class="language-ruby">def tick args
  fade_in_at   = 60
  current_tick = args.state.tick_count
  duration     = 120
  percentage   = args.easing.ease fade_in_at,
                                  current_tick,
                                  duration,
                                  :identity
  alpha = 255 * percentage
  args.outputs.labels &lt;&lt; { x: 640,
                           y: 320, text: "#{percentage.to_sf}",
                           alignment_enum: 1,
                           a: alpha }
end
</code></pre></div><div><h2 id="---easing-definitions">Easing Definitions</h2><p>
There are a number of easing definitions availble to you:
</p><h3 id="------identity-"><code>:identity</code></h3><p>
The easing definition for <code>:identity</code> is <code>f(x) = x</code>. For example, if <code>start_tick</code> is <code>0</code>, <code>current_tick</code> is <code>50</code>, and <code>duration</code> is <code>100</code>, then <code>args.easing.ease 0, 50, 100, :identity</code> will return <code>0.5</code> (since tick <code>50</code> is half way between <code>0</code> and <code>100</code>).
</p><h3 id="------flip-"><code>:flip</code></h3><p>
The easing definition for <code>:flip</code> is <code>f(x) = 1 - x</code>. For example, if <code>start_tick</code> is <code>0</code>, <code>current_tick</code> is <code>10</code>, and <code>duration</code> is <code>100</code>, then <code>args.easing.ease 0, 10, 100, :flip</code> will return <code>0.9</code> (since tick <code>10</code> means 100% - 10%).
</p><h3 id="------quad-----cube-----quart-----qunit-"><code>:quad</code>, <code>:cube</code>, <code>:quart</code>, <code>:qunit</code></h3><p>
These are the power easing definitions. <code>:quad</code> is <code>f(x) = x * x</code> (<code>x</code> squared), <code>:cube</code> is <code>f(x) = x * x * x</code>  (<code>x</code> cubed), etc.
</p><p>
The power easing definitions represent Smooth Start easing (the percentage changes slow at first and speeds up at the end).
</p><h4>Example</h4><p>
Here is an example of Smooth Start (the percentage changes slow at first and speeds up at the end).
</p><pre><code class="language-ruby">def tick args
  start_tick   = 60
  current_tick = args.state.tick_count
  duration     = 120
  percentage   = args.easing.ease start_tick,
                                  current_tick,
                                  duration,
                                  :quad
  start_x      = 100
  end_x        = 1180
  distance_x   = end_x - start_x
  final_x      = start_x + (distance_x * percentage)

  start_y      = 100
  end_y        = 620
  distance_y   = end_y - start_y
  final_y      = start_y + (distance_y * percentage)

  args.outputs.labels &lt;&lt; { x: final_x,
                           y: final_y,
                           text: "#{percentage.to_sf}",
                           alignment_enum: 1 }
end
</code></pre><h3 id="----combining-easing-definitions">Combining Easing Definitions</h3><p>
The base easing definitions can be combined to create common easing functions.
</p><h4>Example</h4><p>
Here is an example of Smooth Stop (the percentage changes fast at first and slows down at the end).
</p><pre><code class="language-ruby">def tick args
  start_tick   = 60
  current_tick = args.state.tick_count
  duration     = 120

  # :flip, :quad, :flip is Smooth Stop
  percentage   = args.easing.ease start_tick,
                                  current_tick,
                                  duration,
                                  :flip, :quad, :flip
  start_x      = 100
  end_x        = 1180
  distance_x   = end_x - start_x
  final_x      = start_x + (distance_x * percentage)

  start_y      = 100
  end_y        = 620
  distance_y   = end_y - start_y
  final_y      = start_y + (distance_y * percentage)

  args.outputs.labels &lt;&lt; { x: final_x,
                           y: final_y,
                           text: "#{percentage.to_sf}",
                           alignment_enum: 1 }
end
</code></pre><h3 id="----custom-easing-functions">Custom Easing Functions</h3><p>
You can define your own easing functions by passing in a <code>lambda</code> as a <code>definition</code> or extending the <code>Easing</code> module.
</p><h4>Example - Using Lambdas</h4><p>
This easing function goes from <code>0</code> to <code>1</code> for the first half of the ease, then <code>1</code> to <code>0</code> for the second half of the ease.
</p><pre><code class="language-ruby">def tick args
  fade_in_at    = 60
  current_tick  = args.state.tick_count
  duration      = 600
  easing_lambda = lambda do |percentage, start_tick, duration|
                    fx = percentage
                    if fx &lt; 0.5
                      fx = percentage * 2
                    else
                      fx = 1 - (percentage - 0.5) * 2
                    end
                    fx
                  end

  percentage    = args.easing.ease fade_in_at,
                                   current_tick,
                                   duration,
                                   easing_lambda

  alpha = 255 * percentage
  args.outputs.labels &lt;&lt; { x: 640,
                           y: 320,
                           a: alpha,
                           text: "#{percentage.to_sf}",
                           alignment_enum: 1 }
end
</code></pre><h4>Example - Extending Easing Definitions</h4><p>
If you don't want to create a lambda, you can register an easing definition like so:
</p><pre><code class="language-ruby"># 1. Extend the Easing module
module Easing
  def self.saw_tooth x
    if x &lt; 0.5
      x * 2
    else
      1 - (x - 0.5) * 2
    end
  end
end

def tick args
  fade_in_at    = 60
  current_tick  = args.state.tick_count
  duration      = 600

  # 2. Reference easing definition by name
  percentage    = args.easing.ease fade_in_at,
                                   current_tick,
                                   duration,
                                   :saw_tooth

  alpha = 255 * percentage
  args.outputs.labels &lt;&lt; { x: 640,
                           y: 320,
                           a: alpha,
                           text: "#{percentage.to_sf}",
                           alignment_enum: 1 }

end
</code></pre></div></div><div id="section---outputs-"><h1 id="---outputs-"><code>Outputs</code></h1><p>
Outputs is how you render primitives to the screen. The minimal setup for rendering something to the screen is via a <code>tick</code> method defined in mygame/app/main.rb
</p><pre><code class="language-ruby">def tick args
  args.outputs.solids     &lt;&lt; [0, 0, 100, 100]
  args.outputs.sprites    &lt;&lt; [100, 100, 100, 100, "sprites/square/blue.png"]
  args.outputs.labels     &lt;&lt; [200, 200, "Hello World"]
  args.outputs.lines      &lt;&lt; [300, 300, 400, 400]
end
</code></pre><div><h2 id="---render-order">Render Order</h2><p>
Primitives are rendered first-in, first-out. The rendering order (sorted by bottom-most to top-most):
</p><ul>
<li><code>solids</code></li>
<li><code>sprites</code></li>
<li><code>primitives</code>: Accepts all render primitives. Useful when you want to bypass the default rendering orders for rendering (eg. rendering solids on top of sprites).</li>
<li><code>labels</code></li>
<li><code>lines</code></li>
<li><code>borders</code></li>
<li><code>debug</code>: Accepts all render primitives. Use this to render primitives for debugging (production builds of your game will not render this layer).</li>
</ul></div></div><div id="section---solids-"><h1 id="---solids-"><code>Solids</code></h1><p>
Add primitives to this collection to render a solid to the screen.
</p><div><h2 id="---rendering-a-solid-using-an-array">Rendering a solid using an Array</h2><p>
Creates a solid black rectangle located at 100, 100. 160 pixels wide and 90 pixels tall.
</p><pre><code class="language-ruby">def tick args
  #                         X    Y  WIDTH  HEIGHT
  args.outputs.solids &lt;&lt; [100, 100,   160,     90]
end
</code></pre></div><div><h2 id="---rendering-a-solid-using-an-array-with-colors-and-alpha">Rendering a solid using an Array with colors and alpha</h2><p>
The value for the color and alpha is a number between <code>0</code> and <code>255</code>. The alpha property is optional and will be set to <code>255</code> if not specified.
</p><p>
Creates a green solid rectangle with an opacity of 50%.
</p><pre><code class="language-ruby">def tick args
  #                         X    Y  WIDTH  HEIGHT  RED  GREEN  BLUE  ALPHA
  args.outputs.solids &lt;&lt; [100, 100,   160,     90,   0,   255,    0,   128]
end
</code></pre></div><div><h2 id="---rendering-a-solid-using-a-hash">Rendering a solid using a Hash</h2><p>
If you want a more readable invocation. You can use the following hash to create a solid. Any parameters that are not specified will be given a default value. The keys of the hash can be provided in any order.
</p><pre><code class="language-ruby">def tick args
  args.outputs.solids &lt;&lt; {
    x:    0,
    y:    0,
    w:  100,
    h:  100,
    r:    0,
    g:  255,
    b:    0,
    a:  255
  }
end
</code></pre></div><div><h2 id="---rendering-a-sprite-using-a-class">Rendering a sprite using a Class</h2><p>
You can also create a class with solid properties and render it as a primitive. ALL properties must be on the class. *Additionally*, a method called <code>primitive_marker</code> must be defined on the class.
</p><p>
Here is an example:
</p><pre><code class="language-ruby"># Create type with ALL solid properties AND primitive_marker
class Solid
  attr_accessor :x, :y, :w, :h, :r, :g, :b, :a

  def primitive_marker
    :solid
  end
end

# Inherit from type
class Square &lt; Solid
  # constructor
  def initialize x, y, size
    self.x = x
    self.y = y
    self.w = size
    self.h = size
  end
end

def tick args
  # render solid/border
  args.outputs.solids  &lt;&lt; Square.new(10, 10, 32)
end
</code></pre></div></div><div id="section---borders-"><h1 id="---borders-"><code>Borders</code></h1><p>
Add primitives to this collection to render an unfilled solid to the screen. Take a look at the documentation for Outputs#solids.
</p><p>
The only difference between the two primitives is where they are added.
</p><p>
Instead of using <code>args.outputs.solids</code>:
</p><pre><code class="language-ruby">def tick args
  #                         X    Y  WIDTH  HEIGHT
  args.outputs.solids &lt;&lt; [100, 100,   160,     90]
end
</code></pre><p>
You have to use <code>args.outputs.borders</code>:
</p><pre><code class="language-ruby">def tick args
  #                           X    Y  WIDTH  HEIGHT
  args.outputs.borders &lt;&lt; [100, 100,   160,     90]
end
</code></pre></div><div id="section---sprites-"><h1 id="---sprites-"><code>Sprites</code></h1><p>
Add primitives to this collection to render a sprite to the screen.
</p><div><h2 id="---rendering-a-sprite-using-an-array">Rendering a sprite using an Array</h2><p>
Creates a sprite of a white circle located at 100, 100. 160 pixels wide and 90 pixels tall.
</p><pre><code class="language-ruby">def tick args
  #                         X    Y   WIDTH   HEIGHT                      PATH
  args.outputs.sprites &lt;&lt; [100, 100,   160,     90, "sprites/circle/white.png]
end
</code></pre></div><div><h2 id="---rendering-a-sprite-using-an-array-with-colors-and-alpha">Rendering a sprite using an Array with colors and alpha</h2><p>
The value for the color and alpha is a number between <code>0</code> and <code>255</code>. The alpha property is optional and will be set to <code>255</code> if not specified.
</p><p>
Creates a green circle sprite with an opacity of 50%.
</p><pre><code class="language-ruby">def tick args
  #                         X    Y  WIDTH  HEIGHT           PATH                ANGLE  ALPHA  RED  GREEN  BLUE
  args.outputs.sprites &lt;&lt; [100, 100,  160,     90, "sprites/circle/white.png",     0,    128,   0,   255,    0]
end
</code></pre></div><div><h2 id="---rendering-a-sprite-using-a-hash">Rendering a sprite using a Hash</h2><p>
If you want a more readable invocation. You can use the following hash to create a sprite. Any parameters that are not specified will be given a default value. The keys of the hash can be provided in any order.
</p><pre><code class="language-ruby">def tick args
  args.outputs.sprites &lt;&lt; {
    x:                             0,
    y:                             0,
    w:                           100,
    h:                           100,
    path: "sprites/circle/white.png",
    angle:                         0,
    a:                           255,
    r:                             0,
    g:                           255,
    b:                             0
  }
end
</code></pre></div><div><h2 id="---rendering-a-solid-using-a-class">Rendering a solid using a Class</h2><p>
You can also create a class with solid/border properties and render it as a primitive. ALL properties must be on the class. *Additionally*, a method called <code>primitive_marker</code> must be defined on the class.
</p><p>
Here is an example:
</p><pre><code class="language-ruby"># Create type with ALL sprite properties AND primitive_marker
class Sprite
  attr_accessor :x, :y, :w, :h, :path, :angle, :angle_anchor_x, :angle_anchor_y,  :tile_x, :tile_y, :tile_w, :tile_h, :source_x, :source_y, :source_w, :source_h, :flip_horizontally, :flip_vertically, :a, :r, :g, :b

  def primitive_marker
    :sprite
  end
end

# Inherit from type
class Circle &lt; Sprite
# constructor
  def initialize x, y, size, path
    self.x = x
    self.y = y
    self.w = size
    self.h = size
    self.path = path
  end
  def serlialize
    {x:self.x, y:self.y, w:self.w, h:self.h, path:self.path}
  end

  def inspect
    serlialize.to_s
  end

  def to_s
    serlialize.to_s
  end
end
def tick args
  # render circle sprite
  args.outputs.sprites  &lt;&lt; Circle.new(10, 10, 32,"sprites/circle/white.png")
end
</code></pre></div></div><div id="section---labels-"><h1 id="---labels-"><code>Labels</code></h1><p>
Add primitives to this collection to render a label.
</p><div><h2 id="---rendering-a-label-using-an-array">Rendering a label using an Array</h2><p>
Labels represented as Arrays/Tuples:
</p><pre><code class="language-ruby">def tick args
                         #        X         Y              TEXT   SIZE_ENUM
  args.outputs.labels &lt;&lt; [175 + 150, 610 - 50, "Smaller label.",         0]
end
</code></pre><p>
Here are all the properties that you can set with a label represented as an Array. It's recommended to move over to using Hashes once you've specified a lot of properties.
</p><pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; [
    640,                   # X
    360,                   # Y
    "Hello world",         # TEXT
    0,                     # SIZE_ENUM
    1,                     # ALIGNMENT_ENUM
    0,                     # RED
    0,                     # GREEN
    0,                     # BLUE
    255,                   # ALPHA
    "fonts/coolfont.ttf"   # FONT
  ]
end
d
</code></pre></div><div><h2 id="---rendering-a-label-using-a-hash">Rendering a label using a Hash</h2><pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; {
      x:                       200,
      y:                       550,
      text:                    "dragonruby",
      size_enum:               2,
      alignment_enum:          1, # 0 = left, 1 = center, 2 = right
      r:                       155,
      g:                       50,
      b:                       50,
      a:                       255,
      font:                    "fonts/manaspc.ttf",
      vertical_alignment_enum: 0  # 0 = bottom, 1 = center, 2 = top
  }
end
</code></pre></div></div><div id="section---screenshots-"><h1 id="---screenshots-"><code>Screenshots</code></h1><p>
Add a hash to this collection to take a screenshot and save as png file. The keys of the hash can be provided in any order.
</p><pre><code class="language-ruby">def tick args
  args.outputs.screenshots &lt;&lt; {
    x: 0, y: 0, w: 100, h: 100,    # Which portion of the screen should be captured
    path: 'screenshot.png',        # Output path of PNG file (inside game directory)
    r: 255, g: 255, b: 255, a: 0   # Optional chroma key
  }
end
</code></pre><div><h2 id="---chroma-key-(making-a-color-transparent)">Chroma key (Making a color transparent)</h2><p>
By specifying the r, g, b and a keys of the hash you change the transparency of a color in the resulting PNG file. This can be useful if you want to create files with transparent background like spritesheets. The transparency of the color specified by <code>r</code>, <code>g</code>, <code>b</code> will be set to the transparency specified by <code>a</code>.
</p><p>
The example above sets the color white (255, 255, 255) as transparent.
</p></div></div><div id="section---mouse-"><h1 id="---mouse-"><code>Mouse</code></h1><p>
The mouse is accessible via <code>args.inputs.mouse</code>:
</p><pre><code class="language-ruby">def tick args
  # Rendering a label that shows the mouse's x and y position (via args.inputs.mouse).
  args.outputs.labels &lt;&lt; [
    10,
    710,
    "The mouse's position is: #{args.inputs.mouse.x} #{args.inputs.mouse.y}."
  ]
end
</code></pre><p>
The mouse has the following properties.
</p><ul>
<li><code>args.inputs.mouse.x</code>: Returns the x position of the mouse.</li>
<li><code>args.inputs.mouse.y</code>: Returns the y position of the mouse.</li>
<li><code>args.inputs.mouse.moved</code>: Returns true if the mouse moved during the tick.</li>
<li><code>args.inputs.mouse.moved_at</code>: Returns the tick_count (<code>args.state.tick_count</code>) that the mouse was moved at. This property will be <code>nil</code> if the mouse didn't move.</li>
<li><code>args.inputs.mouse.global_moved_at</code>: Returns the global tick_count (<code>Kernel.global_tick_count</code>) that the mouse was moved at. This property will be <code>nil</code> if the mouse didn't move.</li>
<li><code>args.inputs.mouse.click</code>: Returns a <code>GTK::MousePoint</code> for that specific frame (<code>args.state.tick_count</code>) if the mouse button was pressed.</li>
<li><code>args.inputs.mouse.previous_click</code>: Returns a <code>GTK::MousePoint</code> for the previous frame (<code>args.state.tick_count - 1</code>) if the mouse button was pressed.</li>
<li><code>args.inputs.mouse.up</code>: Returns true if for that specific frame (<code>args.state.tick_count</code>) if the mouse button was released.</li>
<li><code>args.inputs.mouse.point</code> | <code>args.inputs.mouse.position</code>: Returns an <code>Array</code> which contains the <code>x</code> and <code>y</code> position of the mouse.</li>
<li><code>args.inputs.mouse.has_focus</code>: Returns true if the game window has the mouse's focus.</li>
<li><code>args.inputs.mouse.wheel</code>: Returns an <code>GTK::OpenEntity</code> that contains an <code>x</code> and <code>y</code> property which represents how much the wheel has moved. If the wheel has not moved within the tick, this property will be <code>nil</code>.</li>
<li><code>args.inputs.mouse.button_left</code>: Returns true if the left mouse button is down.</li>
<li><code>args.inputs.mouse.button_right</code>: Returns true if the right mouse button is down.</li>
<li><code>args.inputs.mouse.button_middle</code>: Returns true if the middle mouse button is down.</li>
<li><code>args.inputs.mouse.button_bits</code>: Gives the bits for each mouse button and its current state.</li>
</ul></div><div id="section---openentity-"><h1 id="---openentity-"><code>OpenEntity</code></h1><p>
<code>OpenEntity</code> is accessible within the DragonRuby's top level <code>tick</code> function via the <code>args.state</code> property.
</p><pre><code class="language-ruby">def tick args
  args.state.x ||= 100
  args.outputs.labels &lt;&lt; [10, 710, "value of x is: #{args.state.x}."]
end
</code></pre><p>
The primary benefit of using <code>args.state</code> as opposed to instance variables is that <code>GTK::OpenEntity</code> allows for arbitrary nesting of properties without the need to create intermediate objects.
</p><p>
For example:
</p><pre><code class="language-ruby">def tick args
  # intermediate player object does not need to be created
  args.state.player.x ||= 100
  args.state.player.y ||= 100
  args.outputs.labels &lt;&lt; [
    10,
    710,
    "player x, y is:#{args.state.player.x}, #{args.state.player.y}."
  ]
end
</code></pre><div><h2 id="----as_hash-"><code>as_hash</code></h2><p>
Returns a reference to the <code>GTK::OpenEntity</code> as a <code>Hash</code>. This property is useful when you want to treat <code>args.state</code> as a <code>Hash</code> and invoke methods such as <code>Hash#each</code>.
</p><p>
Example:
</p><pre><code class="language-ruby">def tick args
  args.state.x ||= 100
  args.state.y ||= 100
  values = args.state
               .as_hash
               .map { |k, v| "#{k} #{v}" }

  args.outputs.labels &lt;&lt; values.map.with_index do |v, i|
    [
      10,
      710 - (30 * i),
      v
    ]
  end
end
</code></pre></div></div><div id="section---array-"><h1 id="---array-"><code>Array</code></h1><p>
The Array class has been extend to provide methods that will help in common game development tasks. Array is one of the most powerful classes in Ruby and a very fundamental component of Game Toolkit.
</p><div><h2 id="----map_2d-"><code>map_2d</code></h2><p>
Assuming the array is an array of arrays, Given a block, each 2D array index invoked against the block. A 2D array is a common way to store data/layout for a stage.
</p><pre><code class="language-ruby">repl do
  stage = [
    [:enemy, :empty, :player],
    [:empty, :empty,  :empty],
    [:enemy, :empty,  :enemy],
  ]

  occupied_tiles = stage.map_2d do |row, col, tile|
    if tile == :empty
      nil
    else
      [row, col, tile]
    end
  end.reject_nil

  puts "Stage:"
  puts stage

  puts "Occupied Tiles"
  puts occupied_tiles
end
</code></pre></div><div><h2 id="----include_any--"><code>include_any?</code></h2><p>
Given a collection of items, the function will return <code>true</code> if any of <code>self</code>'s items exists in the collection of items passed in:
</p></div><div><h2 id="----any_intersect_rect--"><code>any_intersect_rect?</code></h2><p>
Assuming the array contains objects that respond to <code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>, this method returns <code>true</code> if any of the elements within the array intersect the object being passed in. You are given an optional parameter called <code>tolerance</code> which informs how close to the other rectangles the elements need to be for it to be considered intersecting.
</p><p>
The default tolerance is set to <code>0.1</code>, which means that the primitives are not considered intersecting unless they are overlapping by more than <code>0.1</code>.
</p><pre><code class="language-ruby">repl do
  # Here is a player class that has position and implement
  # the ~attr_rect~ contract.
  class Player
    attr_rect
    attr_accessor :x, :y, :w, :h

    def initialize x, y, w, h
      @x = x
      @y = y
      @w = w
      @h = h
    end

    def serialize
      { x: @x, y: @y, w: @w, h: @h }
    end

    def inspect
      "#{serialize}"
    end

    def to_s
      "#{serialize}"
    end
  end

  # Here is a definition of two walls.
  walls = [
     [10, 10, 10, 10],
     { x: 20, y: 20, w: 10, h: 10 },
   ]

  # Display the walls.
  puts "Walls."
  puts walls
  puts ""

  # Check any_intersect_rect? on player
  player = Player.new 30, 20, 10, 10
  puts "Is Player #{player} touching wall?"
  puts (walls.any_intersect_rect? player)
  # =&gt; false
  # The value is false because of the default tolerance is 0.1.
  # The overlap of the player rect and any of the wall rects is
  # less than 0.1 (for those that intersect).
  puts ""

  player = Player.new 9, 10, 10, 10
  puts "Is Player #{player} touching wall?"
  puts (walls.any_intersect_rect? player)
  # =&gt; true
  puts ""
end
</code></pre></div><div><h2 id="----map-"><code>map</code></h2><p>
The function given a block returns a new <code>Enumerable</code> of values.
</p><p>
Example of using <code>Array#map</code> in conjunction with <code>args.state</code> and <code>args.outputs.sprites</code> to render sprites to the screen.
</p><pre><code class="language-ruby">def tick args
  # define the colors of the rainbow in ~args.state~
  # as an ~Array~ of ~Hash~es with :order and :name.
  # :order will be used to determine render location
  #  and :name will be used to determine sprite path.
  args.state.rainbow_colors ||= [
    { order: 0, name: :red    },
    { order: 1, name: :orange },
    { order: 2, name: :yellow },
    { order: 3, name: :green  },
    { order: 4, name: :blue   },
    { order: 5, name: :indigo },
    { order: 6, name: :violet },
  ]

  # render sprites diagonally to the screen
  # with a width and height of 50.
  args.outputs
      .sprites &lt;&lt; args.state
                      .rainbow_colors
                      .map do |color| # &lt;-- ~Array#map~ usage
                        [
                          color[:order] * 50,
                          color[:order] * 50,
                          50,
                          50,
                          "sprites/square-#{color[:name]}.png"
                        ]
                      end
end
</code></pre></div><div><h2 id="----each-"><code>each</code></h2><p>
The function, given a block, invokes the block for each item in the <code>Array</code>. <code>Array#each</code> is synonymous to foreach constructs in other languages.
</p><p>
Example of using <code>Array#each</code> in conjunction with <code>args.state</code> and <code>args.outputs.sprites</code> to render sprites to the screen:
</p><pre><code class="language-ruby">def tick args
  # define the colors of the rainbow in ~args.state~
  # as an ~Array~ of ~Hash~es with :order and :name.
  # :order will be used to determine render location
  #  and :name will be used to determine sprite path.
  args.state.rainbow_colors ||= [
    { order: 0, name: :red    },
    { order: 1, name: :orange },
    { order: 2, name: :yellow },
    { order: 3, name: :green  },
    { order: 4, name: :blue   },
    { order: 5, name: :indigo },
    { order: 6, name: :violet },
  ]

  # render sprites diagonally to the screen
  # with a width and height of 50.
  args.state
      .rainbow_colors
      .map do |color| # &lt;-- ~Array#each~ usage
        args.outputs.sprites &lt;&lt; [
          color[:order] * 50,
          color[:order] * 50,
          50,
          50,
          "sprites/square-#{color[:name]}.png"
        ]
      end
end
</code></pre></div><div><h2 id="----reject_nil-"><code>reject_nil</code></h2><p>
Returns an <code>Enumerable</code> rejecting items that are <code>nil</code>, this is an alias for <code>Array#compact</code>:
</p><pre><code class="language-ruby">repl do
  a = [1, nil, 4, false, :a]
  puts a.reject_nil
  # =&gt; [1, 4, false, :a]
  puts a.compact
  # =&gt; [1, 4, false, :a]
end
</code></pre></div><div><h2 id="----reject_false-"><code>reject_false</code></h2><p>
Returns an `Enumerable` rejecting items that are `nil` or `false`.
</p><pre><code class="language-ruby">repl do
  a = [1, nil, 4, false, :a]
  puts a.reject_false
  # =&gt; [1, 4, :a]
end
</code></pre></div><div><h2 id="----product-"><code>product</code></h2><p>
Returns all combinations of values between two arrays.
</p><p>
Here are some examples of using <code>product</code>. Paste the following code at the bottom of main.rb and save the file to see the results:
</p><pre><code class="language-ruby">repl do
  a = [0, 1]
  puts a.product
  # =&gt; [[0, 0], [0, 1], [1, 0], [1, 1]]
end
</code></pre><pre><code class="language-ruby">repl do
  a = [ 0,  1]
  b = [:a, :b]
  puts a.product b
  # =&gt; [[0, :a], [0, :b], [1, :a], [1, :b]]
end
</code></pre></div><div><h2 id="----frame_index-"><code>frame_index</code></h2><p>
This function is helpful for determining the index of frame-by-frame   sprite animation. The numeric value <code>self</code> represents the moment the   animation started.
</p><p>
<code>frame_index</code> takes three additional parameters:
</p><ul>
<li>How many frames exist in the sprite animation.</li>
<li>How long to hold each animation for.</li>
<li>Whether the animation should repeat.</li>
</ul><p>
<code>frame_index</code> will return <code>nil</code> if the time for the animation is out of bounds of the parameter specification.
</p><p>
Example using variables:
</p><pre><code class="language-ruby">def tick args
  start_looping_at = 0
  number_of_sprites = 6
  number_of_frames_to_show_each_sprite = 4
  does_sprite_loop = true

  sprite_index =
    start_looping_at.frame_index number_of_sprites,
                                 number_of_frames_to_show_each_sprite,
                                 does_sprite_loop

  sprite_index ||= 0

  args.outputs.sprites &lt;&lt; [
    640 - 50,
    360 - 50,
    100,
    100,
    "sprites/dragon-#{sprite_index}.png"
  ]
end
</code></pre><p>
Example using named parameters:
</p><pre><code class="language-ruby">def tick args
  start_looping_at = 0

  sprite_index =
    start_looping_at.frame_index count: 6,
                                 hold_for: 4,
                                 repeat: true,
                                 tick_count_override: args.state.tick_count

  sprite_index ||= 0

  args.outputs.sprites &lt;&lt; [
    640 - 50,
    360 - 50,
    100,
    100,
    "sprites/dragon-#{sprite_index}.png"
  ]
end
</code></pre></div><div><h2 id="----elapsed_time-"><code>elapsed_time</code></h2><p>
For a given number, the elapsed frames since that number is returned. `Kernel.tick_count` is used to determine how many frames have elapsed. An optional numeric argument can be passed in which will be used instead of `Kernel.tick_count`.
</p><p>
Here is an example of how elapsed_time can be used.
</p><pre><code class="language-ruby">def tick args
  args.state.last_click_at ||= 0

  # record when a mouse click occurs
  if args.inputs.mouse.click
    args.state.last_click_at = args.state.tick_count
  end

  # Use Numeric#elapsed_time to determine how long it's been
  if args.state.last_click_at.elapsed_time &gt; 120
    args.outputs.labels &lt;&lt; [10, 710, "It has been over 2 seconds since the mouse was clicked."]
  end
end
</code></pre><p>
And here is an example where the override parameter is passed in:
</p><pre><code class="language-ruby">def tick args
  args.state.last_click_at ||= 0

  # create a state variable that tracks time at half the speed of args.state.tick_count
  args.state.simulation_tick = args.state.tick_count.idiv 2

  # record when a mouse click occurs
  if args.inputs.mouse.click
    args.state.last_click_at = args.state.simulation_tick
  end

  # Use Numeric#elapsed_time to determine how long it's been
  if (args.state.last_click_at.elapsed_time args.state.simulation_tick) &gt; 120
    args.outputs.labels &lt;&lt; [10, 710, "It has been over 4 seconds since the mouse was clicked."]
  end
end
</code></pre></div><div><h2 id="----elapsed--"><code>elapsed?</code></h2><p>
Returns true if <code>Numeric#elapsed_time</code> is greater than the number. An optional parameter can be passed into <code>elapsed?</code> which is added to the number before evaluating whether <code>elapsed?</code> is true.
</p><p>
Example usage (no optional parameter):
</p><pre><code class="language-ruby">def tick args
  args.state.box_queue ||= []

  if args.state.box_queue.empty?
    args.state.box_queue &lt;&lt; { name: :red,
                              destroy_at: args.state.tick_count + 60 }
    args.state.box_queue &lt;&lt; { name: :green,
                              destroy_at: args.state.tick_count + 60 }
    args.state.box_queue &lt;&lt; { name: :blue,
                              destroy_at: args.state.tick_count + 120 }
  end

  boxes_to_destroy = args.state
                         .box_queue
                         .find_all { |b| b[:destroy_at].elapsed? }

  if !boxes_to_destroy.empty?
    puts "boxes to destroy count: #{boxes_to_destroy.length}"
  end

  boxes_to_destroy.each { |b| puts "box #{b} was elapsed? on #{args.state.tick_count}." }

  args.state.box_queue -= boxes_to_destroy
end
</code></pre><p>
Example usage (with optional parameter):
</p><pre><code class="language-ruby">def tick args
  args.state.box_queue ||= []

  if args.state.box_queue.empty?
    args.state.box_queue &lt;&lt; { name: :red,
                              create_at: args.state.tick_count + 120,
                              lifespan: 60 }
    args.state.box_queue &lt;&lt; { name: :green,
                              create_at: args.state.tick_count + 120,
                              lifespan: 60 }
    args.state.box_queue &lt;&lt; { name: :blue,
                              create_at: args.state.tick_count + 120,
                              lifespan: 120 }
  end

  # lifespan is passed in as a parameter to ~elapsed?~
  boxes_to_destroy = args.state
                         .box_queue
                         .find_all { |b| b[:create_at].elapsed? b[:lifespan] }

  if !boxes_to_destroy.empty?
    puts "boxes to destroy count: #{boxes_to_destroy.length}"
  end

  boxes_to_destroy.each { |b| puts "box #{b} was elapsed? on #{args.state.tick_count}." }

  args.state.box_queue -= boxes_to_destroy
end
</code></pre></div><div><h2 id="----new--"><code>new?</code></h2><p>
Returns true if <code>Numeric#elapsed_time == 0</code>. Essentially communicating that number is equal to the current frame.
</p><p>
Example usage:
</p><pre><code class="language-ruby">def tick args
  args.state.box_queue ||= []

  if args.state.box_queue.empty?
    args.state.box_queue &lt;&lt; { name: :red,
                              create_at: args.state.tick_count + 60 }
  end

  boxes_to_spawn_this_frame = args.state
                                  .box_queue
                                  .find_all { |b| b[:create_at].new? }

  boxes_to_spawn_this_frame.each { |b| puts "box #{b} was new? on #{args.state.tick_count}." }

  args.state.box_queue -= boxes_to_spawn_this_frame
end
</code></pre></div></div><div id="section---kernel-"><h1 id="---kernel-"><code>Kernel</code></h1><p>
Kernel in the DragonRuby Runtime has patches for how standard out is handled and also contains a unit of time in games called a tick.
</p><div><h2 id="----tick_count-"><code>tick_count</code></h2><p>
Returns the current tick of the game. This value is reset if you call $gtk.reset.
</p></div><div><h2 id="----global_tick_count-"><code>global_tick_count</code></h2><p>
Returns the current tick of the application from the point it was started. This value is never reset.
</p></div></div><div id="section---geometry-"><h1 id="---geometry-"><code>Geometry</code></h1><p>
The Geometry <code>module</code> contains methods for calculations that are frequently used in game development. For convenience, this <code>module</code> is mixed into <code>Hash</code>, <code>Array</code>, and DragonRuby's <code>Entity</code> class. It is also available in a functional variant at <code>args.geometry</code>.
</p><p>
Many of the geometric functions assume the objects have a certain shape:
</p><ul>
<li><code>Points</code> are assumed to respond to <code>x, y</code>.</li>
<li><code>Rectangles</code> are assumed to respond to <code>x, y, w, h</code>.</li>
<li><code>Lines</code> are assumed to respond to <code>x, y, x2, y2</code>.</li>
</ul><pre><code class="language-ruby">def tick args
  # Geometry is mixed into Hash, Array, and Entity

  # define to rectangles
  rect_1 = { x: 0, y: 0, w: 100, h: 100 }
  rect_2 = { x: 50, y: 50, w: 100, h: 100 }

  # call geometry method function from instance of a Hash class
  puts rect_1.intersect_rect?(rect_2)

  # OR

  # use the geometry methods functionally
  puts args.geometry.intersect_rect?(rect_1, rect_2)
end
</code></pre><div><h2 id="----inside_rect--"><code>inside_rect?</code></h2><p>
Invocation variants:
</p><ul>
<li><code>instance.inside_rect?(other)</code></li>
<li><code>args.geometry.inside_rect?(rect_1, rect_2)</code></li>
</ul><p>
Given two rectangle primitives this function will return <code>true</code> or <code>false</code> depending on if the first rectangle (or <code>self</code>) is inside of the second rectangle.
</p><p>
Here is an example where one rectangle is stationary, and another rectangle is controlled using directional input. The rectangles change color from blue to read if the movable rectangle is entirely inside the stationary rectangle.
</p><pre><code class="language-ruby">def tick args
  # define a rectangle in state and position it
  # at the center of the screen with a color of blue
  args.state.box_1 ||= {
    x: 640 - 40,
    y: 360 - 40,
    w: 80,
    h: 80,
    r: 0,
    g: 0,
    b: 255
  }

  # create another rectangle in state and position it
  # at the far left center
  args.state.box_2 ||= {
    x: 0,
    y: 360 - 10,
    w: 20,
    h: 20,
    r: 0,
    g: 0,
    b: 255
  }

  # take the directional input and use that to move the second rectangle around
  # increase or decrease the x value based on if left or right is held
  args.state.box_2.x += args.inputs.left_right * 5
  # increase or decrease the y value based on if up or down is held
  args.state.box_2.y += args.inputs.up_down * 5

  # change the colors of the rectangles based on whether they
  # intersect or not
  if args.state.box_2.inside_rect? args.state.box_1
    args.state.box_1.r = 255
    args.state.box_1.g = 0
    args.state.box_1.b = 0

    args.state.box_2.r = 255
    args.state.box_2.g = 0
    args.state.box_2.b = 0
  else
    args.state.box_1.r = 0
    args.state.box_1.g = 0
    args.state.box_1.b = 255

    args.state.box_2.r = 0
    args.state.box_2.g = 0
    args.state.box_2.b = 255
  end

  # render the rectangles as border primitives on the screen
  args.outputs.borders &lt;&lt; args.state.box_1
  args.outputs.borders &lt;&lt; args.state.box_2
end
</code></pre></div><div><h2 id="----scale_rect-"><code>scale_rect</code></h2><p>
Given a <code>Rectangle</code> this function returns a new rectangle with a scaled size.
</p><ul>
<li><code>ratio</code>: the ratio by which to scale the rect. A ratio of 2 will double the dimensions of the rect while a ratio of 0.5 will halve its dimensions.</li>
<li><code>anchor_x</code> and <code>anchor_y</code> specify the point within the rect from which to resize it. Setting both to 0 will affect the width and height of the rect, leaving x and y unchanged. Setting both to 0.5 will scale all sides of the rect proportionally from the center.</li>
</ul><pre><code class="language-ruby">def tick args
  # a rect at the center of the screen
  args.state.rect_1 ||= { x: 640 - 20, y: 360 - 20, w: 40, h: 40 }

  # render the rect
  args.outputs.borders &lt;&lt; args.state.rect_1

  # the rect half the size with the x and y position unchanged
  args.outputs.borders &lt;&lt; args.state.rect_1.scale_rect(0.5)

  # the rect double the size, repositioned in the center given anchor optional arguments
  args.outputs.borders &lt;&lt; args.state.rect_1.scale_rect(2, 0.5, 0.5)
end
</code></pre></div><div><h2 id="----scale_rect_extended-"><code>scale_rect_extended</code></h2><p>
The behavior is similar to <code>scale_rect</code> except that you can independently control the scale of each axis. The parameters are all named:
</p><ul>
<li><code>percentage_x</code>: percentage to change the width (default value of 1.0)</li>
<li><code>percentage_y</code>: percentage to change the height (default value of 1.0)</li>
<li><code>anchor_x</code>: anchor repositioning of x (default value of 0.0)</li>
<li><code>anchor_y</code>: anchor repositioning of y (default value of 0.0)</li>
</ul><pre><code class="language-ruby">def tick args
  baseline_rect = { x: 640 - 20, y: 360 - 20, w: 40, h: 40 }
  args.state.rect_1 ||= baseline_rect
  args.state.rect_2 ||= baseline_rect.scale_rect_extended(percentage_x: 2,
                                                          percentage_y: 0.5,
                                                          anchor_x: 0.5,
                                                          anchor_y: 1.0)
  args.outputs.borders &lt;&lt; args.state.rect_1
  args.outputs.borders &lt;&lt; args.state.rect_2
end
</code></pre></div><div><h2 id="----anchor_rect-"><code>anchor_rect</code></h2><p>
Returns a new rect that is anchored by an <code>anchor_x</code> and <code>anchor_y</code> value. The width and height of the rectangle is taken into consideration when determining the anchor position:
</p><pre><code class="language-ruby">def tick args
  args.state.rect ||= {
    x: 640,
    y: 360,
    w: 100,
    h: 100
  }

  # rect's center: 640 + 50, 360 + 50
  args.outputs.borders &lt;&lt; args.state.rect.anchor_rect(0, 0)

  # rect's center: 640, 360
  args.outputs.borders &lt;&lt; args.state.rect.anchor_rect(0.5, 0.5)

  # rect's center: 640, 360
  args.outputs.borders &lt;&lt; args.state.rect.anchor_rect(0.5, 0)
end
</code></pre></div><div><h2 id="----angle_from-"><code>angle_from</code></h2><p>
Invocation variants:
</p><ul>
<li><code>args.geometry.angle_from start_point, end_point</code></li>
<li><code>start_point.angle_from end_point</code></li>
</ul><p>
Returns an angle in degrees from the <code>end_point</code> to the <code>start_point</code> (if you want the value in radians, you can call <code>.to_radians</code> on the value returned):
</p><pre><code class="language-ruby">def tick args
  rect_1 ||= {
    x: 0,
    y: 0,
  }

  rect_2 ||= {
    x: 100,
    y: 100,
  }

  angle = rect_1.angle_from rect_2 # returns 225 degrees
  angle_radians = angle.to_radians
  args.outputs.labels &lt;&lt; { x: 30, y: 30.from_top, text: "#{angle}, #{angle_radians}" }

  angle = args.geometry.angle_from rect_1, rect_2 # returns 225 degrees
  angle_radians = angle.to_radians
  args.outputs.labels &lt;&lt; { x: 30, y: 60.from_top, text: "#{angle}, #{angle_radians}" }
end
</code></pre></div><div><h2 id="----angle_to-"><code>angle_to</code></h2><p>
Invocation variants:
</p><ul>
<li><code>args.geometry.angle_to start_point, end_point</code></li>
<li><code>start_point.angle_to end_point</code></li>
</ul><p>
Returns an angle in degrees to the <code>end_point</code> from the <code>start_point</code> (if you want the value in radians, you can call <code>.to_radians</code> on the value returned):
</p><pre><code class="language-ruby">def tick args
  rect_1 ||= {
    x: 0,
    y: 0,
  }

  rect_2 ||= {
    x: 100,
    y: 100,
  }

  angle = rect_1.angle_to rect_2 # returns 45 degrees
  angle_radians = angle.to_radians
  args.outputs.labels &lt;&lt; { x: 30, y: 30.from_top, text: "#{angle}, #{angle_radians}" }

  angle = args.geometry.angle_to rect_1, rect_2 # returns 45 degrees
  angle_radians = angle.to_radians
  args.outputs.labels &lt;&lt; { x: 30, y: 60.from_top, text: "#{angle}, #{angle_radians}" }
end
</code></pre></div><div><h2 id="----distance-"><code>distance</code></h2><p>
Returns the distance between two points;
</p><pre><code class="language-ruby">def tick args
  rect_1 ||= {
    x: 0,
    y: 0,
  }

  rect_2 ||= {
    x: 100,
    y: 100,
  }

  distance = args.geometry.distance rect_1, rect_2
  args.outputs.labels &lt;&lt; {
    x: 30,
    y: 30.from_top,
    text: "#{distance}"
  }

  args.outputs.lines &lt;&lt; {
    x: rect_1.x,
    y: rect_1.y,
    x2: rect_2.x,
    y2: rect_2.y
  }
end
</code></pre></div><div><h2 id="----point_inside_circle--"><code>point_inside_circle?</code></h2><p>
Invocation variants:
</p><ul>
<li><code>point_1.point_inside_circle? circle_center, circle_radius</code></li>
<li><code>args.geometry.point_inside_circle? point_1, circle_center, circle_radius</code></li>
</ul><p>
Returns <code>true</code> if a point is inside of a circle defined as a center point and radius.
</p><pre><code class="language-ruby">def tick args
  # define circle center
  args.state.circle_center ||= {
    x: 640,
    y: 360
  }

  # define circle radius
  args.state.circle_radius ||= 100

  # define point
  args.state.point_1 ||= {
    x: 100,
    y: 100
  }

  # allow point to be moved using keyboard
  args.state.point_1.x += args.inputs.left_right * 5
  args.state.point_1.y += args.inputs.up_down * 5

  # determine if point is inside of circle
  intersection = args.geometry.point_inside_circle? args.state.point_1,
                                                    args.state.circle_center,
                                                    args.state.circle_radius

  # render point as a square
  args.outputs.sprites &lt;&lt; {
    x: args.state.point_1.x - 20,
    y: args.state.point_1.y - 20,
    w: 40,
    h: 40,
    path: "sprites/square/blue.png"
  }

  # if there is an intersection, render a red circle
  # otherwise render a blue circle
  if intersection
    args.outputs.sprites &lt;&lt; {
      x: args.state.circle_center.x - args.state.circle_radius,
      y: args.state.circle_center.y - args.state.circle_radius,
      w: args.state.circle_radius * 2,
      h: args.state.circle_radius * 2,
      path: "sprites/circle/red.png",
      a: 128
    }
  else
    args.outputs.sprites &lt;&lt; {
      x: args.state.circle_center.x - args.state.circle_radius,
      y: args.state.circle_center.y - args.state.circle_radius,
      w: args.state.circle_radius * 2,
      h: args.state.circle_radius * 2,
      path: "sprites/circle/blue.png",
      a: 128
    }
  end
end
</code></pre></div><div><h2 id="----center_inside_rect-"><code>center_inside_rect</code></h2><p>
Invocation variants:
</p><ul>
<li><code>target_rect.center_inside_rect reference_rect</code></li>
<li><code>args.geometry.center_inside_rect target_rect, reference_rect</code></li>
</ul><p>
Given a target rect and a reference rect, the target rect is centered inside the reference rect (a new rect is returned).
</p><pre><code class="language-ruby">def tick args
  rect_1 = {
    x: 0,
    y: 0,
    w: 100,
    h: 100
  }

  rect_2 = {
    x: 640 - 100,
    y: 360 - 100,
    w: 200,
    h: 200
  }

  centered_rect = args.geometry.center_inside_rect rect_1, rect_2
  # OR
  # centered_rect = rect_1.center_inside_rect rect_2

  args.outputs.solids &lt;&lt; rect_1.merge(r: 255)
  args.outputs.solids &lt;&lt; rect_2.merge(b: 255)
  args.outputs.solids &lt;&lt; centered_rect.merge(g: 255)
end
</code></pre></div><div><h2 id="----ray_test-"><code>ray_test</code></h2><p>
Given a point and a line, <code>ray_test</code> returns one of the following symbols based on the location of the point relative to the line: <code>:left</code>, <code>:right</code>, <code>:on</code>
</p><pre><code class="language-ruby">def tick args
  # create a point based off of the mouse location
  point = {
    x: args.inputs.mouse.x,
    y: args.inputs.mouse.y
  }

  # draw a line from the bottom left to the top right
  line = {
    x: 0,
    y: 0,
    x2: 1280,
    y2: 720
  }

  # perform ray_test on point and line
  ray = args.geometry.ray_test point, line

  # output the results of ray test at mouse location
  args.outputs.labels &lt;&lt; {
    x: point.x,
    y: point.y + 25,
    text: "#{ray}",
    alignment_enum: 1,
    vertical_alignment_enum: 1,
  }

  # render line
  args.outputs.lines &lt;&lt; line

  # render point
  args.outputs.solids &lt;&lt; {
    x: point.x - 5,
    y: point.y - 5,
    w: 10,
    h: 10
  }
end
</code></pre></div><div><h2 id="----line_rise_run-"><code>line_rise_run</code></h2><p>
Given a line, this function returns a Hash with <code>x</code> and <code>y</code> keys representing a normalized representation of the rise and run of the line.
</p><pre><code class="language-ruby">def tick args
  # draw a line from the bottom left to the top right
  line = {
    x: 0,
    y: 0,
    x2: 1280,
    y2: 720
  }

  # get rise and run of line
  rise_run = args.geometry.line_rise_run line

  # output the rise and run of line
  args.outputs.labels &lt;&lt; {
    x: 640,
    y: 360,
    text: "#{rise_run}",
    alignment_enum: 1,
    vertical_alignment_enum: 1,
  }

  # render the line
  args.outputs.lines &lt;&lt; line
end
</code></pre></div><div><h2 id="----rotate_point-"><code>rotate_point</code></h2><p>
Given a point and an angle in degrees, a new point is returned that is rotated around the origin by the degrees amount. An optional third argument can be provided to rotate the angle around a point other than the origin.
</p><pre><code class="language-ruby">def tick args
  args.state.rotate_amount ||= 0
  args.state.rotate_amount  += 1

  if args.state.rotate_amount &gt;= 360
    args.state.rotate_amount = 0
  end

  point_1 = {
    x: 100,
    y: 100
  }

  # rotate point around 0, 0
  rotated_point_1 = args.geometry.rotate_point point_1,
                                               args.state.rotate_amount

  args.outputs.solids &lt;&lt; {
    x: rotated_point_1.x - 5,
    y: rotated_point_1.y - 5,
    w: 10,
    h: 10
  }

  point_2 = {
    x: 640 + 100,
    y: 360 + 100
  }

  # rotate point around center screen
  rotated_point_2 = args.geometry.rotate_point point_2,
                                               args.state.rotate_amount,
                                               x: 640, y: 360

  args.outputs.solids &lt;&lt; {
    x: rotated_point_2.x - 5,
    y: rotated_point_2.y - 5,
    w: 10,
    h: 10
  }
end
</code></pre></div><div><h2 id="----find_intersect_rect-"><code>find_intersect_rect</code></h2><p>
Given a rect and a collection of rects, <code>find_intersect_rect</code> returns the first rect that intersects with the the first parameter. If you find yourself doing this:
</p><pre><code class="language-ruby">collision = args.state.terrain.find { |t| t.intersect_rect? args.state.player }
</code></pre><p>
Consider using <code>find_intersect_rect</code> instead (it's more descriptive and faster):
</p><pre><code class="language-ruby">collision = args.geometry.find_intersect_rect args.state.player, args.state.terrain
</code></pre></div><div><h2 id="----find_all_intersect_rect-"><code>find_all_intersect_rect</code></h2><p>
Given a rect and a collection of rects, <code>find_all_intersect_rect</code> returns all rects that intersects with the the first parameter. If you find yourself doing this:
</p><pre><code class="language-ruby">collisions = args.state.terrain.find_all { |t| t.intersect_rect? args.state.player }
</code></pre><p>
Consider using <code>find_all_intersect_rect</code> instead (it's more descriptive and faster):
</p><pre><code class="language-ruby">collisions = args.geometry.find_all_intersect_rect args.state.player, args.state.terrain
</code></pre></div><div><h2 id="----find_intersect_rect_quad_tree-"><code>find_intersect_rect_quad_tree</code></h2><p>
This is a faster collision algorithm for determining if a rectangle intersects any rectangle in an array. In order to use <code>find_intersect_rect_quad_tree</code>, you must first generate a quad tree data structure using <code>create_quad_tree</code>. Use this function if <code>find_intersect_rect</code> isn't fast enough.
</p><pre><code class="language-ruby">def tick args
  # create a player
  args.state.player ||= {
    x: 640 - 10,
    y: 360 - 10,
    w: 20,
    h: 20
  }

  # allow control of player movement using arrow keys
  args.state.player.x += args.inputs.left_right * 5
  args.state.player.y += args.inputs.up_down * 5

  # generate 40 random rectangles
  args.state.boxes ||= 40.map do
    {
      x: 1180 * rand + 50,
      y: 620 * rand + 50,
      w: 100,
      h: 100
    }
  end

  # generate a quad tree based off of rectangles.
  # the quad tree should only be generated once for
  # a given array of rectangles. if the rectangles
  # change, then the quad tree must be regenerated
  args.state.quad_tree ||= args.geometry.quad_tree_create args.state.boxes

  # use quad tree and find_intersect_rect_quad_tree to determine collision with player
  collision = args.geometry.find_intersect_rect_quad_tree args.state.player,
                                                          args.state.quad_tree

  # if there is a collision render a red box
  if collision
    args.outputs.solids &lt;&lt; collision.merge(r: 255)
  end

  # render player as green
  args.outputs.solids &lt;&lt; args.state.player.merge(g: 255)

  # render boxes as borders
  args.outputs.borders &lt;&lt; args.state.boxes
end
</code></pre></div><div><h2 id="----create_quad_tree-"><code>create_quad_tree</code></h2><p>
Generates a quad tree from an array of rectangles. See <code>find_intersect_rect_quad_tree</code> for usage.
</p></div></div></body></html>