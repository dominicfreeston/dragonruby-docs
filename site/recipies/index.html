<!DOCTYPE html><html><head><link rel="stylesheet" href="/css/preflight.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/nord.min.css" /><script src="/js/highlight.min.js"></script><script>hljs.highlightAll();</script></head><body><div id="section--recipies-"><h1 id="--recipies-"><a href="#--recipies-">RECIPIES:</a></h1><div><h2 id="---how-to-determine-what-frame-you-are-on"><a href="#---how-to-determine-what-frame-you-are-on">How To Determine What Frame You Are On</a></h2><p>
There is a property on <code>state</code> called <code>tick_count</code> that is incremented by DragonRuby every time the <code>tick</code> method is called. The following code renders a label that displays the current <code>tick_count</code>.
</p><pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; [10, 670, "#{args.state.tick_count}"]
end
</code></pre></div><div><h2 id="---how-to-get-current-framerate"><a href="#---how-to-get-current-framerate">How To Get Current Framerate</a></h2><p>
Current framerate is a top level property on the Game Toolkit Runtime and is accessible via <code>args.gtk.current_framerate</code>.
</p><pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; [10, 710, "framerate: #{args.gtk.current_framerate.round}"]
end
</code></pre></div><div><h2 id="---how-to-render-a-sprite-using-an-array"><a href="#---how-to-render-a-sprite-using-an-array">How To Render A Sprite Using An Array</a></h2><p>
All file paths should use the forward slash <code>/</code> *not* backslash <code></code>. Game Toolkit includes a number of sprites in the <code>sprites</code> folder (everything about your game is located in the <code>mygame</code> directory).
</p><p>
The following code renders a sprite with a <code>width</code> and <code>height</code> of <code>100</code> in the center of the screen.
</p><p>
<code>args.outputs.sprites</code> is used to render a sprite.
</p><pre><code class="language-ruby">def tick args
  args.outputs.sprites &lt;&lt; [
    640 - 50,                 # X
    360 - 50,                 # Y
    100,                      # W
    100,                      # H
    'sprites/square-blue.png' # PATH
 ]
end
</code></pre></div><div><h2 id="---more-sprite-properties-as-an-array"><a href="#---more-sprite-properties-as-an-array">More Sprite Properties As An Array</a></h2><p>
Here are all the properties you can set on a sprite.
</p><pre><code class="language-ruby">def tick args
  args.outputs.sprites &lt;&lt; [
    100,                       # X
    100,                       # Y
    32,                        # W
    64,                        # H
    'sprites/square-blue.png', # PATH
    0,                         # ANGLE
    255,                       # ALPHA
    0,                         # RED_SATURATION
    255,                       # GREEN_SATURATION
    0                          # BLUE_SATURATION
  ]
end
</code></pre></div><div><h2 id="---different-sprite-representations"><a href="#---different-sprite-representations">Different Sprite Representations</a></h2><p>
Using ordinal positioning can get a little unruly given so many properties you have control over.
</p><p>
You can represent a sprite as a <code>Hash</code>:
</p><pre><code class="language-ruby">def tick args
  args.outputs.sprites &lt;&lt; {
    x: 640 - 50,
    y: 360 - 50,
    w: 100,
    h: 100,

    path: 'sprites/square-blue.png',
    angle: 0,

    a: 255,
    r: 255,
    g: 255,
    b: 255,

    # source_ properties have origin of bottom left
    source_x:  0,
    source_y:  0,
    source_w: -1,
    source_h: -1,

    # tile_ properties have origin of top left
    tile_x:  0,
    tile_y:  0,
    tile_w: -1,
    tile_h: -1,

    flip_vertically: false,
    flip_horizontally: false,

    angle_anchor_x: 0.5,
    angle_anchor_y: 1.0,

    blendmode_enum: 1
  }
end
</code></pre><p>
The <code>blendmode_enum</code> value can be set to <code>0</code> (no blending), <code>1</code> (alpha blending), <code>2</code> (additive blending), <code>3</code> (modulo blending), <code>4</code> (multiply blending).
</p><p>
You can represent a sprite as an <code>object</code>:
</p><pre><code class="language-ruby"># Create type with ALL sprite properties AND primitive_marker
class Sprite
  attr_accessor :x, :y, :w, :h, :path, :angle, :a, :r, :g, :b,
                :source_x, :source_y, :source_w, :source_h,
                :tile_x, :tile_y, :tile_w, :tile_h,
                :flip_horizontally, :flip_vertically,
                :angle_anchor_x, :angle_anchor_y, :blendmode_enum

  def primitive_marker
    :sprite
  end
end

class BlueSquare &lt; Sprite
  def initialize opts
    @x = opts[:x]
    @y = opts[:y]
    @w = opts[:w]
    @h = opts[:h]
    @path = 'sprites/square-blue.png'
  end
end

def tick args
  args.outputs.sprites &lt;&lt; (BlueSquare.new x: 640 - 50,
                                          y: 360 - 50,
                                          w: 50,
                                          h: 50)
end
</code></pre></div><div><h2 id="---how-to-render-a-label"><a href="#---how-to-render-a-label">How To Render A Label</a></h2><p>
<code>args.outputs.labels</code> is used to render labels.
</p><p>
Labels are how you display text. This code will go directly inside of the <code>def tick args</code> method.
</p><p>
Here is the minimum code:
</p><pre><code class="language-ruby">def tick args
  #                       X    Y    TEXT
  args.outputs.labels &lt;&lt; [640, 360, "I am a black label."]
end
</code></pre></div><div><h2 id="---a-colored-label"><a href="#---a-colored-label">A Colored Label</a></h2><pre><code class="language-ruby">def tick args
  # A colored label
  #                       X    Y    TEXT,                   RED    GREEN  BLUE  ALPHA
  args.outputs.labels &lt;&lt; [640, 360, "I am a redish label.", 255,     128,  128,   255]
end
</code></pre></div><div><h2 id="---extended-label-properties"><a href="#---extended-label-properties">Extended Label Properties</a></h2><pre><code class="language-ruby">def tick args
  # A colored label
  #                       X    Y     TEXT           SIZE  ALIGNMENT  RED  GREEN  BLUE  ALPHA  FONT FILE
  args.outputs.labels &lt;&lt; [
    640,                   # X
    360,                   # Y
    "Hello world",         # TEXT
    0,                     # SIZE_ENUM
    1,                     # ALIGNMENT_ENUM
    0,                     # RED
    0,                     # GREEN
    0,                     # BLUE
    255,                   # ALPHA
    "fonts/coolfont.ttf"   # FONT
  ]
end
</code></pre><p>
A <code>SIZE_ENUM</code> of <code>0</code> represents "default size". A <code>negative</code> value will decrease the label size. A <code>positive</code> value will increase the label's size.
</p><p>
An <code>ALIGNMENT_ENUM</code> of <code>0</code> represents "left aligned". <code>1</code> represents "center aligned". <code>2</code> represents "right aligned".
</p></div><div><h2 id="---rendering-a-label-as-a--hash-"><a href="#---rendering-a-label-as-a--hash-">Rendering A Label As A <code>Hash</code></a></h2><p>
You can add additional metadata about your game within a label, which requires you to use a `Hash` instead.
</p><pre><code class="language-ruby">def tick args
  args.outputs.labels &lt;&lt; {
    x:                       200,
    y:                       550,
    text:                    "dragonruby",
    size_enum:               2,
    alignment_enum:          1,
    r:                       155,
    g:                       50,
    b:                       50,
    a:                       255,
    font:                    "fonts/manaspc.ttf",
    vertical_alignment_enum: 0, # 0 is bottom, 1 is middle, 2 is top
    # You can add any properties you like (this will be ignored/won't cause errors)
    game_data_one:  "Something",
    game_data_two: {
       value_1: "value",
       value_2: "value two",
       a_number: 15
    }
  }
end
</code></pre></div><div><h2 id="---getting-the-size-of-a-piece-of-text"><a href="#---getting-the-size-of-a-piece-of-text">Getting The Size Of A Piece Of Text</a></h2><p>
You can get the render size of any string using <code>args.gtk.calcstringbox</code>.
</p><pre><code class="language-ruby">def tick args
  #                             TEXT           SIZE_ENUM  FONT
  w, h = args.gtk.calcstringbox("some string",         0, "font.ttf")

  # NOTE: The SIZE_ENUM and FONT are optional arguments.

  # Render a label showing the w and h of the text:
  args.outputs.labels &lt;&lt; [
    10,
    710,
    # This string uses Ruby's string interpolation literal: #{}
    "'some string' has width: #{w}, and height: #{h}."
  ]
end
</code></pre></div><div><h2 id="---rendering-labels-with-new-line-characters-and-wrapping"><a href="#---rendering-labels-with-new-line-characters-and-wrapping">Rendering Labels With New Line Characters And Wrapping</a></h2><p>
You can use a strategy like the following to create multiple labels from a String.
</p><pre><code class="language-ruby">def tick args
  long_string = "Lorem ipsum dolor sit amet, consectetur adipiscing elitteger dolor velit, ultricies vitae libero vel, aliquam imperdiet enim."
  max_character_length = 30
  long_strings_split = args.string.wrapped_lines long_string, max_character_length
  args.outputs.labels &lt;&lt; long_strings_split.map_with_index do |s, i|
    { x: 10, y: 600 - (i * 20), text: s }
  end
end
</code></pre></div><div><h2 id="---how-to-play-a-sound"><a href="#---how-to-play-a-sound">How To Play A Sound</a></h2><p>
Sounds that end <code>.wav</code> will play once:
</p><pre><code class="language-ruby">def tick args
  # Play a sound every second
  if (args.state.tick_count % 60) == 0
    args.outputs.sounds &lt;&lt; 'something.wav'
  end
end
</code></pre><p>
Sounds that end <code>.ogg</code> is considered background music and will loop:
</p><pre><code class="language-ruby">def tick args
  # Start a sound loop at the beginning of the game
  if args.state.tick_count == 0
    args.outputs.sounds &lt;&lt; 'background_music.ogg'
  end
end
</code></pre><p>
If you want to play a <code>.ogg</code> once as if it were a sound effect, you can do:
</p><pre><code class="language-ruby">def tick args
  # Play a sound every second
  if (args.state.tick_count % 60) == 0
    args.gtk.queue_sound 'some-ogg.ogg'
  end
end
</code></pre></div><div><h2 id="---using--args-state--to-store-your-game-state"><a href="#---using--args-state--to-store-your-game-state">Using <code>args.state</code> To Store Your Game State</a></h2><p>
<code>args.state</code> is a open data structure that allows you to define properties that are arbitrarily nested. You don't need to define any kind of <code>class</code>.
</p><p>
To initialize your game state, use the <code>||=</code> operator. Any value on the right side of <code>||=</code> will only be assigned _once_.
</p><p>
To assign a value every frame, just use the <code>=</code> operator, but _make sure_ you've initialized a default value.
</p><pre><code class="language-ruby">def tick args
  # initialize your game state ONCE
  args.state.player.x  ||= 0
  args.state.player.y  ||= 0
  args.state.player.hp ||= 100

  # increment the x position of the character by one every frame
  args.state.player.x += 1

  # Render a sprite with a label above the sprite
  args.outputs.sprites &lt;&lt; [
    args.state.player.x,
    args.state.player.y,
    32, 32,
    "player.png"
  ]

  args.outputs.labels &lt;&lt; [
    args.state.player.x,
    args.state.player.y - 50,
    args.state.player.hp
  ]
end
</code></pre></div><div><h2 id="---accessing-files"><a href="#---accessing-files">Accessing files</a></h2><p>
DragonRuby uses a sandboxed filesystem which will automatically read from and write to a location appropriate for your platform so you don't have to worry about theses details in your code. You can just use <code>gtk.read_file</code>, <code>gtk.write_file</code>, and <code>gtk.append_file</code> with a relative path and the engine will take care of the rest.
</p><p>
The data directories that will be written to in a production build are:
</p><ul>
<li>Windows: <code>C:\Users\[username]\AppData\Roaming\[devtitle]\[gametitle]</code></li>
<li>MacOS: <code>$HOME/Library/Application Support/[gametitle]</code></li>
<li>Linux: <code>$HOME/.local/share/[gametitle]</code></li>
<li>HTML5: The data will be written to the browser's IndexedDB.</li>
</ul><p>
The values in square brackets are the values you set in your <code>app/metadata/game_metadata.txt</code> file.
</p><p>
When reading files, the engine will first look in the game's data directory and then in the game directory itself. This means that if you write a file to the data directory that already exists in your game directory, the file in the data directory will be used instead of the one that is in your game.
</p><p>
When running a development build you will directly write to your game directory (and thus overwrite existing files). This can be useful for built-in development tools like level editors.
</p><p>
For more details on the implementation of the sandboxed filesystem, see Ryan C. Gordon's PhysicsFS documentation: <a href="https://icculus.org/physfs/">https://icculus.org/physfs/</a>
</p></div><div><h2 id="---troubleshoot-performance"><a href="#---troubleshoot-performance">Troubleshoot Performance</a></h2><ol>
<li> If you're using <code>Array</code>s for your primitives (<code>args.outputs.sprites &lt;&lt; []</code>), use <code>Hash</code> instead (<code>args.outputs.sprites &lt;&lt; { x: ... }</code>).</li>
<li> If you're using <code>Entity</code> for your primitives (<code>args.outputs.sprites &lt;&lt; args.state.new_entity</code>), use <code>StrictEntity</code> instead (<code>args.outputs.sprites &lt;&lt; args.state.new_entity_strict</code>).</li>
<li> Use <code>.each</code> instead of <code>.map</code> if you don't care about the return value.</li>
<li> When concatenating primitives to outputs, do them in bulk. Instead of:</li>
</ol><pre><code class="language-ruby">args.state.bullets.each do |bullet|
  args.outputs.sprites &lt;&lt; bullet.sprite
end
</code></pre><p>
do
</p><pre><code class="language-ruby">args.outputs.sprites &lt;&lt; args.state.bullets.map do |b|
  b.sprite
end
</code></pre><p>
5. Use <code>args.outputs.static_</code> variant for things that don't change often (take a look at the Basic Gorillas sample app and Dueling Starships sample app to see how <code>static_</code> is leveraged.
</p><p>
6. Consider using a <code>render_target</code> if you're doing some form of a camera that moves a lot of primitives (take a look at the Render Target sample apps for more info).
</p></div></div></body></html>